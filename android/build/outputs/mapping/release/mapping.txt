# compiler: R8
# compiler_version: 3.3.83
# min_api: 16
# common_typos_disable
# {"id":"com.android.tools.r8.mapping","version":"2.0"}
# pg_map_id: 09f79ac
# pg_map_hash: SHA-256 09f79ac8f5897bb47b5e65147c8c0a632bc63ee69b692d7f091e3d1401c01366
android.app.AppComponentFactory -> android.app.AppComponentFactory:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void <init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    android.app.Activity instantiateActivity(java.lang.ClassLoader,java.lang.String,android.content.Intent) -> instantiateActivity
      # {"id":"com.android.tools.r8.synthesized"}
    android.app.Application instantiateApplication(java.lang.ClassLoader,java.lang.String) -> instantiateApplication
      # {"id":"com.android.tools.r8.synthesized"}
    android.content.ContentProvider instantiateProvider(java.lang.ClassLoader,java.lang.String) -> instantiateProvider
      # {"id":"com.android.tools.r8.synthesized"}
    android.content.BroadcastReceiver instantiateReceiver(java.lang.ClassLoader,java.lang.String,android.content.Intent) -> instantiateReceiver
      # {"id":"com.android.tools.r8.synthesized"}
    android.app.Service instantiateService(java.lang.ClassLoader,java.lang.String,android.content.Intent) -> instantiateService
      # {"id":"com.android.tools.r8.synthesized"}
android.graphics.drawable.AdaptiveIconDrawable -> android.graphics.drawable.AdaptiveIconDrawable:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void <init>(android.graphics.drawable.Drawable,android.graphics.drawable.Drawable) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
android.graphics.drawable.Icon -> android.graphics.drawable.Icon:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon createWithBitmap(android.graphics.Bitmap) -> createWithBitmap
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon createWithContentUri(java.lang.String) -> createWithContentUri
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon createWithData(byte[],int,int) -> createWithData
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon createWithResource(java.lang.String,int) -> createWithResource
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Drawable loadDrawable(android.content.Context) -> loadDrawable
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon setTintList(android.content.res.ColorStateList) -> setTintList
      # {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon setTintMode(android.graphics.PorterDuff$Mode) -> setTintMode
      # {"id":"com.android.tools.r8.synthesized"}
android.hardware.display.DisplayManager -> android.hardware.display.DisplayManager:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    android.view.Display getDisplay(int) -> getDisplay
      # {"id":"com.android.tools.r8.synthesized"}
android.media.AudioAttributes -> android.media.AudioAttributes:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
android.media.AudioAttributes$Builder -> android.media.AudioAttributes$Builder:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void <init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    android.media.AudioAttributes build() -> build
      # {"id":"com.android.tools.r8.synthesized"}
    android.media.AudioAttributes$Builder setContentType(int) -> setContentType
      # {"id":"com.android.tools.r8.synthesized"}
    android.media.AudioAttributes$Builder setUsage(int) -> setUsage
      # {"id":"com.android.tools.r8.synthesized"}
android.media.AudioRouting -> android.media.AudioRouting:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
android.media.SoundPool$Builder -> android.media.SoundPool$Builder:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void <init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    android.media.SoundPool build() -> build
      # {"id":"com.android.tools.r8.synthesized"}
    android.media.SoundPool$Builder setAudioAttributes(android.media.AudioAttributes) -> setAudioAttributes
      # {"id":"com.android.tools.r8.synthesized"}
    android.media.SoundPool$Builder setMaxStreams(int) -> setMaxStreams
      # {"id":"com.android.tools.r8.synthesized"}
android.media.VolumeAutomation -> android.media.VolumeAutomation:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
android.opengl.GLES30 -> android.opengl.GLES30:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void glBindVertexArray(int) -> glBindVertexArray
      # {"id":"com.android.tools.r8.synthesized"}
    void glDrawArraysInstanced(int,int,int,int) -> glDrawArraysInstanced
      # {"id":"com.android.tools.r8.synthesized"}
    void glDrawElementsInstanced(int,int,int,int,int) -> glDrawElementsInstanced
      # {"id":"com.android.tools.r8.synthesized"}
    void glGenVertexArrays(int,java.nio.IntBuffer) -> glGenVertexArrays
      # {"id":"com.android.tools.r8.synthesized"}
    void glTexImage3D(int,int,int,int,int,int,int,int,int,int) -> glTexImage3D
      # {"id":"com.android.tools.r8.synthesized"}
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage3D
      # {"id":"com.android.tools.r8.synthesized"}
android.view.DisplayCutout -> android.view.DisplayCutout:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    int getSafeInsetBottom() -> getSafeInsetBottom
      # {"id":"com.android.tools.r8.synthesized"}
    int getSafeInsetLeft() -> getSafeInsetLeft
      # {"id":"com.android.tools.r8.synthesized"}
    int getSafeInsetRight() -> getSafeInsetRight
      # {"id":"com.android.tools.r8.synthesized"}
    int getSafeInsetTop() -> getSafeInsetTop
      # {"id":"com.android.tools.r8.synthesized"}
android.view.PointerIcon -> android.view.PointerIcon:
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    android.view.PointerIcon getSystemIcon(android.content.Context,int) -> getSystemIcon
      # {"id":"com.android.tools.r8.synthesized"}
androidx.collection.ArrayMap -> a.a:
    androidx.collection.MapCollections mCollections -> k
    androidx.collection.MapCollections getCollection() -> m
androidx.collection.ArrayMap$1 -> a.a$a:
    androidx.collection.ArrayMap this$0 -> d
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> b
    java.util.Map colGetMap() -> c
    int colGetSize() -> d
    int colIndexOfKey(java.lang.Object) -> e
    int colIndexOfValue(java.lang.Object) -> f
    void colPut(java.lang.Object,java.lang.Object) -> g
    void colRemoveAt(int) -> h
    java.lang.Object colSetValue(int,java.lang.Object) -> i
androidx.collection.ContainerHelpers -> a.b:
    java.lang.Object[] EMPTY_OBJECTS -> c
    long[] EMPTY_LONGS -> b
    int[] EMPTY_INTS -> a
    int binarySearch(int[],int,int) -> a
    boolean equal(java.lang.Object,java.lang.Object) -> b
androidx.collection.MapCollections -> a.c:
    androidx.collection.MapCollections$KeySet mKeySet -> b
    androidx.collection.MapCollections$ValuesCollection mValues -> c
    androidx.collection.MapCollections$EntrySet mEntrySet -> a
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> b
    java.util.Map colGetMap() -> c
    int colGetSize() -> d
    int colIndexOfKey(java.lang.Object) -> e
    int colIndexOfValue(java.lang.Object) -> f
    void colPut(java.lang.Object,java.lang.Object) -> g
    void colRemoveAt(int) -> h
    java.lang.Object colSetValue(int,java.lang.Object) -> i
    boolean containsAllHelper(java.util.Map,java.util.Collection) -> j
    boolean equalsSetHelper(java.util.Set,java.lang.Object) -> k
    java.util.Set getEntrySet() -> l
    java.util.Set getKeySet() -> m
    java.util.Collection getValues() -> n
    boolean removeAllHelper(java.util.Map,java.util.Collection) -> o
    boolean retainAllHelper(java.util.Map,java.util.Collection) -> p
    java.lang.Object[] toArrayHelper(int) -> q
    java.lang.Object[] toArrayHelper(java.lang.Object[],int) -> r
androidx.collection.MapCollections$ArrayIterator -> a.c$a:
    androidx.collection.MapCollections this$0 -> h
    int mIndex -> f
    int mOffset -> d
    boolean mCanRemove -> g
    int mSize -> e
androidx.collection.MapCollections$EntrySet -> a.c$b:
    androidx.collection.MapCollections this$0 -> d
    boolean add(java.util.Map$Entry) -> a
androidx.collection.MapCollections$KeySet -> a.c$c:
    androidx.collection.MapCollections this$0 -> d
androidx.collection.MapCollections$MapIterator -> a.c$d:
    androidx.collection.MapCollections this$0 -> g
    boolean mEntryValid -> f
    int mEnd -> d
    int mIndex -> e
    java.util.Map$Entry next() -> a
androidx.collection.MapCollections$ValuesCollection -> a.c$e:
    androidx.collection.MapCollections this$0 -> d
androidx.collection.SimpleArrayMap -> a.d:
    java.lang.Object[] mArray -> e
    int mTwiceBaseCacheSize -> j
    int[] mHashes -> d
    int mBaseCacheSize -> h
    int mSize -> f
    java.lang.Object[] mTwiceBaseCache -> i
    java.lang.Object[] mBaseCache -> g
    void allocArrays(int) -> a
    int binarySearchHashes(int[],int,int) -> b
    void ensureCapacity(int) -> c
    void freeArrays(int[],java.lang.Object[],int) -> d
    int indexOf(java.lang.Object,int) -> e
    int indexOfKey(java.lang.Object) -> f
    int indexOfNull() -> g
    int indexOfValue(java.lang.Object) -> h
    java.lang.Object keyAt(int) -> i
    java.lang.Object removeAt(int) -> j
    java.lang.Object setValueAt(int,java.lang.Object) -> k
    java.lang.Object valueAt(int) -> l
androidx.core.app.CoreComponentFactory -> androidx.core.app.CoreComponentFactory:
    java.lang.Object checkCompatWrapper(java.lang.Object) -> a
androidx.core.app.CoreComponentFactory$CompatWrapped -> androidx.core.app.CoreComponentFactory$a:
    java.lang.Object getWrapper() -> a
androidx.core.app.RemoteActionCompat -> androidx.core.app.RemoteActionCompat:
    androidx.core.graphics.drawable.IconCompat mIcon -> a
    java.lang.CharSequence mTitle -> b
    java.lang.CharSequence mContentDescription -> c
    boolean mEnabled -> e
    boolean mShouldShowIcon -> f
    android.app.PendingIntent mActionIntent -> d
androidx.core.graphics.drawable.IconCompat -> androidx.core.graphics.drawable.IconCompat:
    java.lang.String mTintModeStr -> i
    android.graphics.PorterDuff$Mode DEFAULT_TINT_MODE -> k
    java.lang.String mString1 -> j
    android.graphics.PorterDuff$Mode mTintMode -> h
    android.os.Parcelable mParcelable -> d
    java.lang.Object mObj1 -> b
    int mInt2 -> f
    android.content.res.ColorStateList mTintList -> g
    int mInt1 -> e
    byte[] mData -> c
    int mType -> a
    android.graphics.Bitmap createLegacyIconFromAdaptiveIcon(android.graphics.Bitmap,boolean) -> a
    int getResId() -> b
    java.lang.String getResPackage() -> c
    android.net.Uri getUri() -> d
    java.io.InputStream getUriInputStream(android.content.Context) -> e
    void onPostParceling() -> f
    void onPreParceling(boolean) -> g
    java.lang.String typeToString(int) -> h
androidx.core.graphics.drawable.IconCompat$Api23Impl -> androidx.core.graphics.drawable.IconCompat$a:
    int getResId(java.lang.Object) -> a
    java.lang.String getResPackage(java.lang.Object) -> b
    android.net.Uri getUri(java.lang.Object) -> c
    android.graphics.drawable.Drawable loadDrawable(android.graphics.drawable.Icon,android.content.Context) -> d
    android.graphics.drawable.Icon toIcon(androidx.core.graphics.drawable.IconCompat,android.content.Context) -> e
androidx.core.graphics.drawable.IconCompat$Api26Impl -> androidx.core.graphics.drawable.IconCompat$b:
    android.graphics.drawable.Drawable createAdaptiveIconDrawable(android.graphics.drawable.Drawable,android.graphics.drawable.Drawable) -> a
    android.graphics.drawable.Icon createWithAdaptiveBitmap(android.graphics.Bitmap) -> b
androidx.core.graphics.drawable.IconCompat$Api26Impl$$ExternalSyntheticApiModelOutline0 -> androidx.core.graphics.drawable.a:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon androidx.core.graphics.drawable.IconCompat$Api26Impl$$InternalSyntheticApiModelOutline$1$3a1863954de92d345fea86dfae7f369931cf45f524cdaf33c34d0f40a283b310$0.m(android.graphics.Bitmap) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl -> androidx.core.graphics.drawable.IconCompat$c:
    int getResId(java.lang.Object) -> a
    java.lang.String getResPackage(java.lang.Object) -> b
    int getType(java.lang.Object) -> c
    android.net.Uri getUri(java.lang.Object) -> d
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline0 -> androidx.core.graphics.drawable.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$0cc1fb17db561c5ba334428991ab275abe874bc3f63f42e6ae00a455df2f29af$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline1 -> androidx.core.graphics.drawable.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.net.Uri androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$1d5cd78ab5bc2ba7c5847bdfe6baf67c823a02789768df43e179f05a9e3c22c3$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline2 -> androidx.core.graphics.drawable.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$40b39641b9d6ef68de58f9b92a6906fe9b99705bdf062dc89a3ea0a21d65018d$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline3 -> androidx.core.graphics.drawable.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.lang.String androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$425daee209e8ac6dbaf4d4161c4994372512a53b633026f0a72c7baf9f5b568e$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api30Impl -> androidx.core.graphics.drawable.IconCompat$d:
    android.graphics.drawable.Icon createWithAdaptiveBitmapContentUri(android.net.Uri) -> a
androidx.core.graphics.drawable.IconCompat$Api30Impl$$ExternalSyntheticApiModelOutline0 -> androidx.core.graphics.drawable.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon androidx.core.graphics.drawable.IconCompat$Api30Impl$$InternalSyntheticApiModelOutline$1$181d250257b606f3a0952ed61d731be99dd28d4f22e07105279bf0946c8d21f1$0.m(android.net.Uri) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.lifecycle.LiveData$ObserverWrapper -> androidx.lifecycle.a:
androidx.savedstate.Recreator -> androidx.savedstate.Recreator:
    androidx.savedstate.Recreator$Companion Companion -> a
androidx.savedstate.Recreator$Companion -> androidx.savedstate.Recreator$a:
androidx.versionedparcelable.ParcelImpl -> androidx.versionedparcelable.ParcelImpl:
    androidx.versionedparcelable.VersionedParcelable mParcel -> d
androidx.versionedparcelable.ParcelImpl$1 -> androidx.versionedparcelable.ParcelImpl$a:
    androidx.versionedparcelable.ParcelImpl createFromParcel(android.os.Parcel) -> a
    androidx.versionedparcelable.ParcelImpl[] newArray(int) -> b
androidx.versionedparcelable.VersionedParcel -> androidx.versionedparcelable.a:
    androidx.collection.ArrayMap mParcelizerCache -> c
    androidx.collection.ArrayMap mReadCache -> a
    androidx.collection.ArrayMap mWriteCache -> b
    void writeByteArray(byte[]) -> A
    void writeByteArray(byte[],int) -> B
    void writeCharSequence(java.lang.CharSequence) -> C
    void writeCharSequence(java.lang.CharSequence,int) -> D
    void writeInt(int) -> E
    void writeInt(int,int) -> F
    void writeParcelable(android.os.Parcelable) -> G
    void writeParcelable(android.os.Parcelable,int) -> H
    void writeString(java.lang.String) -> I
    void writeString(java.lang.String,int) -> J
    void writeToParcel(androidx.versionedparcelable.VersionedParcelable,androidx.versionedparcelable.VersionedParcel) -> K
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable) -> L
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> M
    void writeVersionedParcelableCreator(androidx.versionedparcelable.VersionedParcelable) -> N
    void closeField() -> a
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> b
    java.lang.Class findParcelClass(java.lang.Class) -> c
    java.lang.reflect.Method getReadMethod(java.lang.String) -> d
    java.lang.reflect.Method getWriteMethod(java.lang.Class) -> e
    boolean isStream() -> f
    boolean readBoolean() -> g
    boolean readBoolean(boolean,int) -> h
    byte[] readByteArray() -> i
    byte[] readByteArray(byte[],int) -> j
    java.lang.CharSequence readCharSequence() -> k
    java.lang.CharSequence readCharSequence(java.lang.CharSequence,int) -> l
    boolean readField(int) -> m
    androidx.versionedparcelable.VersionedParcelable readFromParcel(java.lang.String,androidx.versionedparcelable.VersionedParcel) -> n
    int readInt() -> o
    int readInt(int,int) -> p
    android.os.Parcelable readParcelable() -> q
    android.os.Parcelable readParcelable(android.os.Parcelable,int) -> r
    java.lang.String readString() -> s
    java.lang.String readString(java.lang.String,int) -> t
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable() -> u
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> v
    void setOutputField(int) -> w
    void setSerializationFlags(boolean,boolean) -> x
    void writeBoolean(boolean) -> y
    void writeBoolean(boolean,int) -> z
androidx.versionedparcelable.VersionedParcelParcel -> androidx.versionedparcelable.b:
    android.util.SparseIntArray mPositionLookup -> d
    java.lang.String mPrefix -> h
    int mNextRead -> j
    android.os.Parcel mParcel -> e
    int mFieldId -> k
    int mCurrentField -> i
    int mOffset -> f
    int mEnd -> g
    void writeByteArray(byte[]) -> A
    void writeCharSequence(java.lang.CharSequence) -> C
    void writeInt(int) -> E
    void writeParcelable(android.os.Parcelable) -> G
    void writeString(java.lang.String) -> I
    void closeField() -> a
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> b
    boolean readBoolean() -> g
    byte[] readByteArray() -> i
    java.lang.CharSequence readCharSequence() -> k
    boolean readField(int) -> m
    int readInt() -> o
    android.os.Parcelable readParcelable() -> q
    java.lang.String readString() -> s
    void setOutputField(int) -> w
    void writeBoolean(boolean) -> y
androidx.versionedparcelable.VersionedParcelable -> b.a:
com.badlogic.gdx.AbstractGraphics -> c.a:
com.badlogic.gdx.AbstractInput -> c.b:
    boolean[] justPressedKeys -> e
    boolean[] pressedKeys -> d
    com.badlogic.gdx.utils.IntSet keysToCatch -> f
    int pressedKeyCount -> g
    boolean keyJustPressed -> h
    boolean isKeyPressed(int) -> a
    boolean isKeyJustPressed(int) -> j
    boolean isCatchBackKey() -> m
    boolean isCatchKey(int) -> p
    void setCatchKey(int,boolean) -> q
com.badlogic.gdx.Application -> c.c:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    com.badlogic.gdx.Application$ApplicationType getType() -> f
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void log(java.lang.String,java.lang.String) -> h
    void exit() -> i
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> j
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> k
    void postRunnable(java.lang.Runnable) -> l
    int getVersion() -> m
    com.badlogic.gdx.Graphics getGraphics() -> o
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> p
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> r
    com.badlogic.gdx.utils.Clipboard getClipboard() -> s
com.badlogic.gdx.Application$ApplicationType -> c.c$a:
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> j
    com.badlogic.gdx.Application$ApplicationType iOS -> i
    com.badlogic.gdx.Application$ApplicationType WebGL -> h
    com.badlogic.gdx.Application$ApplicationType Desktop -> e
    com.badlogic.gdx.Application$ApplicationType Android -> d
    com.badlogic.gdx.Application$ApplicationType Applet -> g
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> f
com.badlogic.gdx.ApplicationListener -> c.d:
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    void resize(int,int) -> d
    void create() -> e
    void render() -> f
com.badlogic.gdx.ApplicationLogger -> c.e:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void log(java.lang.String,java.lang.String) -> h
com.badlogic.gdx.Audio -> c.f:
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> l
com.badlogic.gdx.Files -> c.g:
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getLocalStoragePath() -> c
    java.lang.String getExternalStoragePath() -> d
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> e
com.badlogic.gdx.Files$FileType -> c.g$a:
    com.badlogic.gdx.Files$FileType External -> f
    com.badlogic.gdx.Files$FileType Internal -> e
    com.badlogic.gdx.Files$FileType Classpath -> d
    com.badlogic.gdx.Files$FileType[] $VALUES -> i
    com.badlogic.gdx.Files$FileType Local -> h
    com.badlogic.gdx.Files$FileType Absolute -> g
com.badlogic.gdx.Game -> c.h:
    com.badlogic.gdx.Screen screen -> a
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render() -> f
    void setScreen(com.badlogic.gdx.Screen) -> g
com.badlogic.gdx.Gdx -> c.i:
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.graphics.GL30 gl30 -> i
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    com.badlogic.gdx.graphics.GL20 gl -> g
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
com.badlogic.gdx.Graphics -> c.j:
    int getWidth() -> a
    int getHeight() -> b
    void setForegroundFPS(int) -> c
    int getBackBufferWidth() -> d
    void setVSync(boolean) -> e
    boolean setFullscreenMode(com.badlogic.gdx.Graphics$DisplayMode) -> f
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> g
    float getDeltaTime() -> h
    boolean setWindowedMode(int,int) -> i
    int getBackBufferHeight() -> j
    void setSystemCursor(com.badlogic.gdx.graphics.Cursor$SystemCursor) -> k
    boolean supportsExtension(java.lang.String) -> l
    void requestRendering() -> m
    boolean isGL30Available() -> n
    void setContinuousRendering(boolean) -> o
com.badlogic.gdx.Graphics$BufferFormat -> c.j$a:
    int stencil -> f
    int samples -> g
    int a -> d
    int depth -> e
    boolean coverageSampling -> h
    int g -> b
    int b -> c
    int r -> a
com.badlogic.gdx.Graphics$DisplayMode -> c.j$b:
    int bitsPerPixel -> d
    int height -> b
    int refreshRate -> c
    int width -> a
com.badlogic.gdx.Input -> c.k:
    boolean isKeyPressed(int) -> a
    long getCurrentEventTime() -> b
    int getX() -> c
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> h
    boolean isKeyJustPressed(int) -> j
    void setOnscreenKeyboardVisible(boolean) -> l
    boolean isCatchBackKey() -> m
    int getY() -> n
    boolean isTouched(int) -> o
com.badlogic.gdx.Input$OnscreenKeyboardType -> c.k$a:
    com.badlogic.gdx.Input$OnscreenKeyboardType Email -> g
    com.badlogic.gdx.Input$OnscreenKeyboardType[] $VALUES -> j
    com.badlogic.gdx.Input$OnscreenKeyboardType PhonePad -> f
    com.badlogic.gdx.Input$OnscreenKeyboardType URI -> i
    com.badlogic.gdx.Input$OnscreenKeyboardType Password -> h
    com.badlogic.gdx.Input$OnscreenKeyboardType NumberPad -> e
    com.badlogic.gdx.Input$OnscreenKeyboardType Default -> d
com.badlogic.gdx.Input$Orientation -> c.k$b:
    com.badlogic.gdx.Input$Orientation Portrait -> e
    com.badlogic.gdx.Input$Orientation Landscape -> d
    com.badlogic.gdx.Input$Orientation[] $VALUES -> f
com.badlogic.gdx.InputAdapter -> c.l:
    boolean keyUp(int) -> A
    boolean keyTyped(char) -> C
    boolean keyDown(int) -> F
    boolean touchCancelled(int,int,int,int) -> J
    boolean scrolled(float,float) -> K
    boolean mouseMoved(int,int) -> p
com.badlogic.gdx.InputProcessor -> c.m:
    boolean keyUp(int) -> A
    boolean keyTyped(char) -> C
    boolean keyDown(int) -> F
    boolean touchCancelled(int,int,int,int) -> J
    boolean scrolled(float,float) -> K
    boolean touchDragged(int,int,int) -> M
    boolean touchDown(int,int,int,int) -> l
    boolean mouseMoved(int,int) -> p
    boolean touchUp(int,int,int,int) -> t
com.badlogic.gdx.LifecycleListener -> c.n:
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.Net -> c.o:
com.badlogic.gdx.Preferences -> c.p:
    com.badlogic.gdx.Preferences putInteger(java.lang.String,int) -> a
    int getInteger(java.lang.String,int) -> b
com.badlogic.gdx.Screen -> c.q:
    void pause() -> a
    void show() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render(float) -> e
    void hide() -> f
com.badlogic.gdx.assets.AssetLoaderParameters -> d.a:
com.badlogic.gdx.assets.loaders.AssetLoader -> e.a:
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> a
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader -> e.b:
com.badlogic.gdx.assets.loaders.FileHandleResolver -> e.c:
com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver -> f.a:
com.badlogic.gdx.audio.Music -> g.a:
com.badlogic.gdx.audio.Music$OnCompletionListener -> g.a$a:
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.badlogic.gdx.audio.Sound -> g.b:
    void setVolume(long,float) -> r
    long play(float) -> y
com.badlogic.gdx.backends.android.AndroidApplication -> h.a:
    int logLevel -> n
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    boolean useImmersiveMode -> p
    boolean firstResume -> i
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.utils.SnapshotArray lifecycleListeners -> l
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    boolean isWaitingForAudio -> r
    com.badlogic.gdx.utils.Array androidEventListeners -> m
    com.badlogic.gdx.ApplicationLogger applicationLogger -> o
    com.badlogic.gdx.utils.Array executedRunnables -> k
    com.badlogic.gdx.utils.Array runnables -> j
    com.badlogic.gdx.ApplicationListener listener -> g
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> f
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    android.os.Handler handler -> h
    int wasFocusChanged -> q
    com.badlogic.gdx.ApplicationLogger getApplicationLogger() -> A
    com.badlogic.gdx.Audio getAudio() -> B
    com.badlogic.gdx.Files getFiles() -> C
    com.badlogic.gdx.Net getNet() -> D
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> E
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> F
    void setApplicationLogger(com.badlogic.gdx.ApplicationLogger) -> G
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    android.content.Context getContext() -> c
    com.badlogic.gdx.utils.Array getRunnables() -> d
    void useImmersiveMode(boolean) -> e
    com.badlogic.gdx.Application$ApplicationType getType() -> f
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void log(java.lang.String,java.lang.String) -> h
    void exit() -> i
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> j
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> k
    void postRunnable(java.lang.Runnable) -> l
    int getVersion() -> m
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> n
    com.badlogic.gdx.Graphics getGraphics() -> o
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> p
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> q
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> r
    com.badlogic.gdx.utils.Clipboard getClipboard() -> s
    android.view.Window getApplicationWindow() -> t
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> u
    com.badlogic.gdx.backends.android.AndroidAudio createAudio(android.content.Context,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> v
    com.badlogic.gdx.backends.android.AndroidFiles createFiles() -> w
    com.badlogic.gdx.backends.android.AndroidInput createInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> x
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> y
    void createWakeLock(boolean) -> z
com.badlogic.gdx.backends.android.AndroidApplication$1 -> h.a$a:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> d
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.backends.android.AndroidApplication$2 -> h.a$b:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> d
com.badlogic.gdx.backends.android.AndroidApplicationBase -> h.b:
    android.content.Context getContext() -> c
    com.badlogic.gdx.utils.Array getRunnables() -> d
    void useImmersiveMode(boolean) -> e
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> n
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> q
    android.view.Window getApplicationWindow() -> t
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> u
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> h.c:
    boolean useWakelock -> n
    int sensorDelay -> l
    boolean disableAudio -> o
    int touchSleepTime -> m
    boolean useGyroscope -> i
    boolean useCompass -> j
    boolean useRotationVectorSensor -> k
    int stencil -> f
    int numSamples -> g
    int a -> d
    int depth -> e
    int g -> b
    int b -> c
    boolean getTouchEventsForLiveWallpaper -> r
    com.badlogic.gdx.backends.android.GdxNativeLoader nativeLoader -> v
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> q
    boolean useImmersiveMode -> s
    int r -> a
    boolean useGL30 -> t
    boolean useAccelerometer -> h
    int maxNetThreads -> u
    int maxSimultaneousSounds -> p
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration$1 -> h.c$a:
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration this$0 -> a
    void load() -> a
com.badlogic.gdx.backends.android.AndroidApplicationLogger -> h.d:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void log(java.lang.String,java.lang.String) -> h
com.badlogic.gdx.backends.android.AndroidAudio -> h.e:
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> B
    void pause() -> a
    void resume() -> c
com.badlogic.gdx.backends.android.AndroidClipboard -> h.f:
    android.content.ClipboardManager clipboard -> a
    void setContents(java.lang.String) -> a
    java.lang.String getContents() -> b
com.badlogic.gdx.backends.android.AndroidCursor -> h.h:
    void setSystemCursor(android.view.View,com.badlogic.gdx.graphics.Cursor$SystemCursor) -> l
com.badlogic.gdx.backends.android.AndroidCursor$$ExternalSyntheticApiModelOutline0 -> h.g:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    void com.badlogic.gdx.backends.android.AndroidCursor$$InternalSyntheticApiModelOutline$1$bdc095ee40f20ed7e70cba9addce19ead5983aa3426e3af94cf6592d45e150c8$0.m(android.view.View,android.view.PointerIcon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidCursor$1 -> h.h$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$Cursor$SystemCursor -> a
com.badlogic.gdx.backends.android.AndroidEventListener -> h.i:
    void onActivityResult(int,int,android.content.Intent) -> a
com.badlogic.gdx.backends.android.AndroidFileHandle -> h.j:
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    boolean exists() -> c
    java.io.File file() -> e
    long length() -> f
    java.nio.ByteBuffer map(java.nio.channels.FileChannel$MapMode) -> h
    com.badlogic.gdx.files.FileHandle parent() -> k
    java.io.InputStream read() -> m
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> q
    android.content.res.AssetFileDescriptor getAssetFileDescriptor() -> s
com.badlogic.gdx.backends.android.AndroidFiles -> h.k:
com.badlogic.gdx.backends.android.AndroidGL20 -> h.l:
    int[] ints2 -> b
    int[] ints3 -> c
    int[] ints -> a
    byte[] buffer -> d
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> A
    void glDisableVertexAttribArray(int) -> B
    void glCompileShader(int) -> C
    int glGenBuffer() -> D
    void glBindFramebuffer(int,int) -> E
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> F
    int glGenTexture() -> G
    int glCreateProgram() -> H
    void glDrawElements(int,int,int,int) -> I
    void glUniform1i(int,int) -> J
    void glBindBuffer(int,int) -> K
    int glCreateShader(int) -> L
    void glGenerateMipmap(int) -> a
    void glLinkProgram(int) -> b
    void glBlendFuncSeparate(int,int,int,int) -> c
    void glTexParameteri(int,int,int) -> d
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> e
    void glUseProgram(int) -> g
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> h
    void glBufferSubData(int,int,int,java.nio.Buffer) -> i
    int glGenFramebuffer() -> k
    java.lang.String glGetProgramInfoLog(int) -> l
    void glEnableVertexAttribArray(int) -> m
    void glBufferData(int,int,java.nio.Buffer,int) -> o
    int glGetUniformLocation(int,java.lang.String) -> p
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> r
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> t
    void glGetFloatv(int,java.nio.FloatBuffer) -> u
    void glShaderSource(int,java.lang.String) -> v
    void glAttachShader(int,int) -> w
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> x
    java.lang.String glGetShaderInfoLog(int) -> y
    int glGetAttribLocation(int,java.lang.String) -> z
com.badlogic.gdx.backends.android.AndroidGL30 -> h.m:
    void glDrawArraysInstanced(int,int,int,int) -> f
    void glDrawElementsInstanced(int,int,int,int,int) -> j
    void glGenVertexArrays(int,java.nio.IntBuffer) -> n
    void glBindVertexArray(int) -> q
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> s
com.badlogic.gdx.backends.android.AndroidGraphics -> h.q:
    com.badlogic.gdx.graphics.GL30 gl30 -> j
    com.badlogic.gdx.graphics.GL20 gl20 -> i
    int safeInsetBottom -> f
    boolean running -> u
    int safeInsetLeft -> d
    boolean resume -> w
    float ppcY -> B
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> E
    int width -> b
    com.badlogic.gdx.graphics.glutils.GLVersion glVersion -> l
    int[] value -> G
    float ppiX -> y
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> h
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> D
    long frameId -> q
    float deltaTime -> o
    int fps -> s
    java.lang.Object synch -> H
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 view -> a
    boolean enforceContinuousRendering -> I
    java.lang.String extensions -> m
    int safeInsetRight -> g
    boolean pause -> v
    float density -> C
    int safeInsetTop -> e
    boolean destroy -> x
    float ppcX -> A
    int height -> c
    boolean created -> t
    float ppiY -> z
    javax.microedition.khronos.egl.EGLContext eglContext -> k
    boolean isContinuous -> F
    long lastFrameTime -> n
    int frames -> r
    long frameStart -> p
    void onResumeGLSurfaceView() -> A
    void pause() -> B
    void preserveEGLContextOnPause() -> C
    void resume() -> D
    void setupGL(javax.microedition.khronos.opengles.GL10) -> E
    void updatePpi() -> F
    void updateSafeAreaInsets() -> G
    int getWidth() -> a
    int getHeight() -> b
    void setForegroundFPS(int) -> c
    int getBackBufferWidth() -> d
    void setVSync(boolean) -> e
    boolean setFullscreenMode(com.badlogic.gdx.Graphics$DisplayMode) -> f
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> g
    float getDeltaTime() -> h
    boolean setWindowedMode(int,int) -> i
    int getBackBufferHeight() -> j
    void setSystemCursor(com.badlogic.gdx.graphics.Cursor$SystemCursor) -> k
    boolean supportsExtension(java.lang.String) -> l
    void requestRendering() -> m
    boolean isGL30Available() -> n
    void setContinuousRendering(boolean) -> o
    boolean checkGL20() -> p
    void clearManagedCaches() -> q
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> r
    void destroy() -> s
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> t
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> u
    android.view.View getView() -> v
    boolean isContinuousRendering() -> w
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> x
    void logManagedCachesStatus() -> y
    void onPauseGLSurfaceView() -> z
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline0 -> h.n:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.view.WindowInsets com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$0.m(android.view.View) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline1 -> h.o:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.view.DisplayCutout com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$1.m(android.view.WindowInsets) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline2 -> h.p:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    void com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$d2605d588f1817ca4b17a1785152158a59c39dbecb235f42d81266c1a6519bfc$0.m(android.view.Display,android.util.DisplayMetrics) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$1 -> h.q$a:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> d
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> h.q$b:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidHaptics -> h.s:
    android.os.Vibrator vibrator -> a
    boolean vibratorSupport -> c
    android.media.AudioAttributes audioAttributes -> b
    boolean hapticsSupport -> d
com.badlogic.gdx.backends.android.AndroidHaptics$$ExternalSyntheticApiModelOutline0 -> h.r:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean com.badlogic.gdx.backends.android.AndroidHaptics$$InternalSyntheticApiModelOutline$1$96efbbcc3c82c74532b1ed7977c9b90fbc5e32dae5a082f8ef412aa99bd91b70$0.m(android.os.Vibrator) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidInput -> h.t:
    void addKeyListener(android.view.View$OnKeyListener) -> d
    void onResume() -> e
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> f
    void setKeyboardAvailable(boolean) -> g
    void onPause() -> i
    void processEvents() -> k
com.badlogic.gdx.backends.android.AndroidMouseHandler -> h.u:
    int deltaY -> b
    int deltaX -> a
    boolean onGenericMotion(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
com.badlogic.gdx.backends.android.AndroidMusic -> h.v:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> a
    com.badlogic.gdx.audio.Music$OnCompletionListener onCompletionListener -> e
    android.media.MediaPlayer player -> b
    boolean isPrepared -> c
    boolean wasPlaying -> d
    void pause() -> a
    void dispose() -> b
    boolean isPlaying() -> l
    void play() -> p
com.badlogic.gdx.backends.android.AndroidMusic$1 -> h.v$a:
    com.badlogic.gdx.backends.android.AndroidMusic this$0 -> d
com.badlogic.gdx.backends.android.AndroidNet -> h.w:
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> a
com.badlogic.gdx.backends.android.AndroidPreferences -> h.x:
    android.content.SharedPreferences$Editor editor -> b
    android.content.SharedPreferences sharedPrefs -> a
    com.badlogic.gdx.Preferences putInteger(java.lang.String,int) -> a
    int getInteger(java.lang.String,int) -> b
    void edit() -> c
com.badlogic.gdx.backends.android.AndroidSound -> h.y:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    com.badlogic.gdx.utils.IntArray streamIds -> d
    int soundId -> c
    void setVolume(long,float) -> r
    long play(float) -> y
com.badlogic.gdx.backends.android.AndroidTouchHandler -> h.z:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
    boolean supportsMultitouch(android.content.Context) -> c
    int toGdxButton(int) -> d
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> h.a0:
    void createListener(com.badlogic.gdx.backends.android.AndroidApplicationBase) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 -> h.a0$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener this$0 -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase val$application -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1$1 -> h.a0$a$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 this$1 -> d
com.badlogic.gdx.backends.android.DefaultAndroidAudio -> h.b0:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    java.util.List musics -> c
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> B
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> l
com.badlogic.gdx.backends.android.DefaultAndroidFiles -> h.c0:
    android.content.res.AssetManager assets -> c
    java.lang.String externalFilesPath -> a
    java.lang.String localpath -> b
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getLocalStoragePath() -> c
    java.lang.String getExternalStoragePath() -> d
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> e
    java.lang.String initExternalFilesPath(android.content.ContextWrapper) -> f
com.badlogic.gdx.backends.android.DefaultAndroidInput -> h.e0:
    float[] rotationVectorValues -> M
    android.hardware.SensorEventListener gyroscopeListener -> W
    boolean[] justPressedButtons -> w
    android.hardware.SensorEventListener rotationVectorListener -> Y
    com.badlogic.gdx.backends.android.AndroidMouseHandler mouseHandler -> a0
    int[] button -> s
    boolean rotationVectorAvailable -> J
    boolean requestFocus -> b0
    int sleepTime -> G
    com.badlogic.gdx.InputProcessor processor -> R
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> F
    com.badlogic.gdx.Application app -> D
    java.util.ArrayList touchEvents -> m
    java.util.ArrayList keyListeners -> k
    boolean accelerometerAvailable -> y
    float[] accelerometerValues -> z
    int[] touchX -> n
    com.badlogic.gdx.utils.Pool usedTouchEvents -> j
    int[] deltaX -> p
    android.hardware.SensorManager manager -> x
    boolean gyroscopeAvailable -> A
    float roll -> P
    float azimuth -> N
    com.badlogic.gdx.backends.android.AndroidHaptics haptics -> H
    android.hardware.SensorEventListener accelerometerListener -> V
    float[] orientation -> d0
    android.hardware.SensorEventListener compassListener -> X
    float[] magneticFieldValues -> L
    float[] R -> c0
    boolean compassAvailable -> I
    java.util.ArrayList genericMotionListeners -> Z
    int[] realId -> t
    boolean keyboardAvailable -> K
    boolean[] touched -> r
    boolean hasMultitouch -> v
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> S
    android.content.Context context -> E
    boolean justTouched -> Q
    float[] gyroscopeValues -> B
    com.badlogic.gdx.Input$Orientation nativeOrientation -> T
    java.util.ArrayList keyEvents -> l
    android.os.Handler handle -> C
    long currentEventTimeStamp -> U
    com.badlogic.gdx.utils.Pool usedKeyEvents -> i
    float[] pressure -> u
    int[] touchY -> o
    int[] deltaY -> q
    float pitch -> O
    void setOnscreenKeyboardVisible(boolean,com.badlogic.gdx.Input$OnscreenKeyboardType) -> A
    void unregisterSensorListeners() -> B
    long getCurrentEventTime() -> b
    int getX() -> c
    void addKeyListener(android.view.View$OnKeyListener) -> d
    void onResume() -> e
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> f
    void setKeyboardAvailable(boolean) -> g
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> h
    void onPause() -> i
    void processEvents() -> k
    void setOnscreenKeyboardVisible(boolean) -> l
    int getY() -> n
    boolean isTouched(int) -> o
    int getAndroidInputType(com.badlogic.gdx.Input$OnscreenKeyboardType) -> r
    int getFreePointerIndex() -> s
    int getRotation() -> t
    boolean isCursorCatched() -> u
    int lookUpPointerIndex(int) -> v
    void registerSensorListeners() -> w
    float[] resize(float[]) -> x
    int[] resize(int[]) -> y
    boolean[] resize(boolean[]) -> z
com.badlogic.gdx.backends.android.DefaultAndroidInput$$ExternalSyntheticApiModelOutline0 -> h.d0:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean com.badlogic.gdx.backends.android.DefaultAndroidInput$$InternalSyntheticApiModelOutline$1$5d33fa66ab41b6a842ffc1740bb8e3964c1adfafdcf97136dde28c68295ffeaa$0.m(android.view.View) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.DefaultAndroidInput$1 -> h.e0$a:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$2 -> h.e0$b:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$4 -> h.e0$c:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> f
    com.badlogic.gdx.Input$OnscreenKeyboardType val$type -> e
    boolean val$visible -> d
com.badlogic.gdx.backends.android.DefaultAndroidInput$6 -> h.e0$d:
    int[] $SwitchMap$com$badlogic$gdx$Input$OnscreenKeyboardType -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent -> h.e0$e:
    long timeStamp -> a
    int type -> b
    char keyChar -> d
    int keyCode -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$SensorListener -> h.e0$f:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent -> h.e0$g:
    int pointer -> h
    int scrollAmountY -> f
    long timeStamp -> a
    int button -> g
    int y -> d
    int scrollAmountX -> e
    int type -> b
    int x -> c
com.badlogic.gdx.backends.android.GdxNativeLoader -> h.f0:
    void load() -> a
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> i.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> i.b:
    int targetGLESVersion -> d
    java.lang.String TAG -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType onscreenKeyboardType -> b
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
    boolean checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
    void init(boolean,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> i.b$a:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> i.b$b:
    int[] mValue -> g
    int[] s_configAttribs2 -> h
    int mStencilSize -> f
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> i.b$c:
    int EGL_CONTEXT_CLIENT_VERSION -> a
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> i.c:
    int[] mConfigAttribs -> h
    int[] mValue -> i
    int mStencilSize -> f
    int mNumSamples -> g
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> i.d:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> i.d$a:
    int height -> b
    int width -> a
com.badlogic.gdx.controllers.AbstractControllerManager -> j.a:
    com.badlogic.gdx.controllers.Controller currentController -> e
    com.badlogic.gdx.utils.Array controllers -> d
    com.badlogic.gdx.controllers.Controller access$000(com.badlogic.gdx.controllers.AbstractControllerManager) -> h
    com.badlogic.gdx.controllers.Controller access$002(com.badlogic.gdx.controllers.AbstractControllerManager,com.badlogic.gdx.controllers.Controller) -> j
com.badlogic.gdx.controllers.AbstractControllerManager$ManageCurrentControllerListener -> j.a$a:
    com.badlogic.gdx.controllers.AbstractControllerManager this$0 -> a
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    void disconnected(com.badlogic.gdx.controllers.Controller) -> b
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> c
    void connected(com.badlogic.gdx.controllers.Controller) -> d
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> e
com.badlogic.gdx.controllers.Controller -> j.b:
com.badlogic.gdx.controllers.ControllerAdapter -> j.c:
com.badlogic.gdx.controllers.ControllerListener -> j.d:
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    void disconnected(com.badlogic.gdx.controllers.Controller) -> b
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> c
    void connected(com.badlogic.gdx.controllers.Controller) -> d
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> e
com.badlogic.gdx.controllers.android.AndroidController -> com.badlogic.gdx.controllers.android.a:
    com.badlogic.gdx.utils.IntIntMap buttons -> c
    float povY -> g
    java.lang.String uuid -> j
    float povX -> f
    boolean connected -> k
    int[] axesIds -> e
    float[] axes -> d
    boolean povAxis -> h
    com.badlogic.gdx.utils.Array listeners -> i
    java.lang.String name -> b
    int deviceId -> a
    float getAxis(int) -> a
    boolean getButton(int) -> b
    com.badlogic.gdx.utils.Array getListeners() -> c
    java.lang.String getName() -> d
    boolean hasPovAxis() -> e
com.badlogic.gdx.controllers.android.AndroidControllerEvent -> com.badlogic.gdx.controllers.android.b:
    float axisValue -> d
    int type -> b
    int code -> c
    com.badlogic.gdx.controllers.android.AndroidController controller -> a
com.badlogic.gdx.controllers.android.AndroidControllers -> com.badlogic.gdx.controllers.android.AndroidControllers:
    com.badlogic.gdx.utils.IntMap controllerMap -> f
    boolean ignoreNoGamepadButtons -> j
    com.badlogic.gdx.utils.Pool eventPool -> i
    com.badlogic.gdx.utils.Array eventQueue -> h
    com.badlogic.gdx.utils.Array listeners -> g
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    com.badlogic.gdx.utils.Array access$000(com.badlogic.gdx.controllers.android.AndroidControllers) -> l
    com.badlogic.gdx.utils.Array access$100(com.badlogic.gdx.controllers.android.AndroidControllers) -> m
    com.badlogic.gdx.utils.Array access$200(com.badlogic.gdx.controllers.android.AndroidControllers) -> n
    com.badlogic.gdx.utils.Array access$300(com.badlogic.gdx.controllers.android.AndroidControllers) -> o
    com.badlogic.gdx.utils.Pool access$400(com.badlogic.gdx.controllers.android.AndroidControllers) -> p
    void addController(int,boolean) -> q
    void gatherControllers(boolean) -> r
    boolean isController(android.view.InputDevice) -> s
    void removeController(int) -> t
    void setupEventQueue() -> u
com.badlogic.gdx.controllers.android.AndroidControllers$1 -> com.badlogic.gdx.controllers.android.AndroidControllers$a:
    com.badlogic.gdx.controllers.android.AndroidControllers this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.controllers.android.AndroidControllerEvent newObject() -> g
com.badlogic.gdx.controllers.android.AndroidControllers$2 -> com.badlogic.gdx.controllers.android.AndroidControllers$b:
    com.badlogic.gdx.controllers.android.AndroidControllers this$0 -> d
com.badlogic.gdx.controllers.android.ControllerLifeCycleListener -> com.badlogic.gdx.controllers.android.c:
    com.badlogic.gdx.controllers.android.AndroidControllers controllers -> e
    android.hardware.input.InputManager inputManager -> d
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.files.FileHandle -> k.a:
    java.io.File file -> a
    com.badlogic.gdx.Files$FileType type -> b
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    int estimateLength() -> b
    boolean exists() -> c
    java.lang.String extension() -> d
    java.io.File file() -> e
    long length() -> f
    java.nio.ByteBuffer map() -> g
    java.nio.ByteBuffer map(java.nio.channels.FileChannel$MapMode) -> h
    java.lang.String name() -> i
    java.lang.String nameWithoutExtension() -> j
    com.badlogic.gdx.files.FileHandle parent() -> k
    java.lang.String path() -> l
    java.io.InputStream read() -> m
    byte[] readBytes() -> n
    java.io.BufferedReader reader(int) -> o
    java.io.Reader reader(java.lang.String) -> p
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> q
    com.badlogic.gdx.Files$FileType type() -> r
com.badlogic.gdx.files.FileHandle$1 -> k.a$a:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.graphics.Camera -> l.a:
    float viewportHeight -> k
    float viewportWidth -> j
    float far -> i
    float near -> h
    com.badlogic.gdx.math.Vector3 tmpVec -> m
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.collision.Ray ray -> n
    com.badlogic.gdx.math.Vector3 project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    com.badlogic.gdx.math.Vector3 unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
    void update() -> c
com.badlogic.gdx.graphics.Color -> l.b:
    com.badlogic.gdx.graphics.Color RED -> E
    com.badlogic.gdx.graphics.Color CORAL -> G
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> f
    com.badlogic.gdx.graphics.Color PINK -> I
    com.badlogic.gdx.graphics.Color DARK_GRAY -> h
    com.badlogic.gdx.graphics.Color PURPLE -> K
    float b -> c
    float r -> a
    com.badlogic.gdx.graphics.Color ORANGE -> A
    com.badlogic.gdx.graphics.Color TAN -> C
    com.badlogic.gdx.graphics.Color CHARTREUSE -> t
    com.badlogic.gdx.graphics.Color FOREST -> v
    com.badlogic.gdx.graphics.Color YELLOW -> x
    com.badlogic.gdx.graphics.Color GOLDENROD -> z
    com.badlogic.gdx.graphics.Color MAROON -> M
    com.badlogic.gdx.graphics.Color BLUE -> l
    com.badlogic.gdx.graphics.Color ROYAL -> n
    com.badlogic.gdx.graphics.Color SKY -> p
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color WHITE -> e
    com.badlogic.gdx.graphics.Color FIREBRICK -> D
    com.badlogic.gdx.graphics.Color GRAY -> g
    float WHITE_FLOAT_BITS -> j
    com.badlogic.gdx.graphics.Color SCARLET -> F
    com.badlogic.gdx.graphics.Color BLACK -> i
    com.badlogic.gdx.graphics.Color SALMON -> H
    com.badlogic.gdx.graphics.Color CLEAR -> k
    com.badlogic.gdx.graphics.Color MAGENTA -> J
    float a -> d
    float g -> b
    com.badlogic.gdx.graphics.Color BROWN -> B
    com.badlogic.gdx.graphics.Color LIME -> u
    com.badlogic.gdx.graphics.Color OLIVE -> w
    com.badlogic.gdx.graphics.Color GOLD -> y
    com.badlogic.gdx.graphics.Color NAVY -> m
    com.badlogic.gdx.graphics.Color VIOLET -> L
    com.badlogic.gdx.graphics.Color SLATE -> o
    com.badlogic.gdx.graphics.Color CYAN -> q
    com.badlogic.gdx.graphics.Color GREEN -> s
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,float) -> a
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,int) -> b
    com.badlogic.gdx.graphics.Color clamp() -> c
    com.badlogic.gdx.graphics.Color cpy() -> d
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> e
    int rgba8888(float,float,float,float) -> f
    int rgba8888(com.badlogic.gdx.graphics.Color) -> g
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> h
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> i
    com.badlogic.gdx.graphics.Color set(int) -> j
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> k
    float toFloatBits() -> l
    float toFloatBits(float,float,float,float) -> m
    int toIntBits() -> n
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> o
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String,com.badlogic.gdx.graphics.Color) -> p
com.badlogic.gdx.graphics.Colors -> l.c:
    com.badlogic.gdx.utils.ObjectMap map -> a
    com.badlogic.gdx.graphics.Color get(java.lang.String) -> a
    void reset() -> b
com.badlogic.gdx.graphics.Cubemap -> l.d:
    com.badlogic.gdx.graphics.CubemapData data -> i
    java.util.Map managedCubemaps -> j
    void clearAllCubemaps(com.badlogic.gdx.Application) -> P
    java.lang.String getManagedStatus() -> Q
    void invalidateAllCubemaps(com.badlogic.gdx.Application) -> R
    boolean isManaged() -> S
    void load(com.badlogic.gdx.graphics.CubemapData) -> T
    void reload() -> U
com.badlogic.gdx.graphics.CubemapData -> l.e:
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    void consumeCubemapData() -> g
com.badlogic.gdx.graphics.Cursor$SystemCursor -> l.f:
    com.badlogic.gdx.graphics.Cursor$SystemCursor NotAllowed -> m
    com.badlogic.gdx.graphics.Cursor$SystemCursor AllResize -> l
    com.badlogic.gdx.graphics.Cursor$SystemCursor[] $VALUES -> o
    com.badlogic.gdx.graphics.Cursor$SystemCursor None -> n
    com.badlogic.gdx.graphics.Cursor$SystemCursor Crosshair -> f
    com.badlogic.gdx.graphics.Cursor$SystemCursor Arrow -> d
    com.badlogic.gdx.graphics.Cursor$SystemCursor Hand -> g
    com.badlogic.gdx.graphics.Cursor$SystemCursor Ibeam -> e
    com.badlogic.gdx.graphics.Cursor$SystemCursor VerticalResize -> i
    com.badlogic.gdx.graphics.Cursor$SystemCursor HorizontalResize -> h
    com.badlogic.gdx.graphics.Cursor$SystemCursor NESWResize -> k
    com.badlogic.gdx.graphics.Cursor$SystemCursor NWSEResize -> j
com.badlogic.gdx.graphics.GL20 -> l.g:
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> A
    void glDisableVertexAttribArray(int) -> B
    void glCompileShader(int) -> C
    int glGenBuffer() -> D
    void glBindFramebuffer(int,int) -> E
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> F
    int glGenTexture() -> G
    int glCreateProgram() -> H
    void glDrawElements(int,int,int,int) -> I
    void glUniform1i(int,int) -> J
    void glBindBuffer(int,int) -> K
    int glCreateShader(int) -> L
    void glGenerateMipmap(int) -> a
    void glLinkProgram(int) -> b
    void glBlendFuncSeparate(int,int,int,int) -> c
    void glTexParameteri(int,int,int) -> d
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> e
    void glUseProgram(int) -> g
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> h
    void glBufferSubData(int,int,int,java.nio.Buffer) -> i
    int glGenFramebuffer() -> k
    java.lang.String glGetProgramInfoLog(int) -> l
    void glEnableVertexAttribArray(int) -> m
    void glBufferData(int,int,java.nio.Buffer,int) -> o
    int glGetUniformLocation(int,java.lang.String) -> p
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> r
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> t
    void glGetFloatv(int,java.nio.FloatBuffer) -> u
    void glShaderSource(int,java.lang.String) -> v
    void glAttachShader(int,int) -> w
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> x
    java.lang.String glGetShaderInfoLog(int) -> y
    int glGetAttribLocation(int,java.lang.String) -> z
com.badlogic.gdx.graphics.GL30 -> l.h:
    void glDrawArraysInstanced(int,int,int,int) -> f
    void glDrawElementsInstanced(int,int,int,int,int) -> j
    void glGenVertexArrays(int,java.nio.IntBuffer) -> n
    void glBindVertexArray(int) -> q
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> s
com.badlogic.gdx.graphics.GLTexture -> l.i:
    float maxAnisotropicFilterLevel -> h
    float anisotropicFilterLevel -> g
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    int glTarget -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> A
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> C
    float unsafeSetAnisotropicFilter(float,boolean) -> F
    void bind() -> I
    void unsafeSetFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> J
    void unsafeSetWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap,boolean) -> K
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> M
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> O
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> l
    float getMaxAnisotropicFilterLevel() -> p
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> t
com.badlogic.gdx.graphics.Mesh -> l.j:
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> a
    com.badlogic.gdx.graphics.glutils.IndexData indices -> b
    com.badlogic.gdx.graphics.glutils.InstanceData instances -> e
    boolean isInstanced -> f
    boolean autoBind -> c
    boolean isVertexArray -> d
    com.badlogic.gdx.math.Vector3 tmpV -> g
    java.util.Map meshes -> h
    void clearAllMeshes(com.badlogic.gdx.Application) -> A
    java.nio.ShortBuffer getIndicesBuffer(boolean) -> C
    java.lang.String getManagedStatus() -> F
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> J
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> K
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> M
    com.badlogic.gdx.graphics.glutils.VertexData makeVertexBuffer(boolean,int,com.badlogic.gdx.graphics.VertexAttributes) -> O
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> P
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> Q
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int,boolean) -> R
    com.badlogic.gdx.graphics.Mesh setIndices(short[]) -> S
    com.badlogic.gdx.graphics.Mesh setVertices(float[],int,int) -> T
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> U
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[],int[]) -> V
    int getNumVertices() -> e
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> l
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> p
    int getNumIndices() -> s
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[],int[]) -> t
com.badlogic.gdx.graphics.Mesh$1 -> l.j$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$Mesh$VertexDataType -> a
com.badlogic.gdx.graphics.Mesh$VertexDataType -> l.j$b:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> f
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectWithVAO -> g
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> e
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> h
com.badlogic.gdx.graphics.OrthographicCamera -> l.k:
    com.badlogic.gdx.math.Vector3 tmp -> p
    float zoom -> o
    void update() -> c
    void update(boolean) -> d
com.badlogic.gdx.graphics.Pixmap -> l.l:
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> c
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> a
    boolean disposed -> e
    com.badlogic.gdx.graphics.Pixmap$Filter filter -> b
    int color -> d
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> A
    void fill() -> C
    void setColor(com.badlogic.gdx.graphics.Color) -> D
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> F
    int getGLFormat() -> J
    int getGLInternalFormat() -> K
    int getGLType() -> M
    int getHeight() -> O
    int getPixel(int,int) -> P
    java.nio.ByteBuffer getPixels() -> Q
    int getWidth() -> R
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> S
    void dispose() -> b
    void drawPixel(int,int,int) -> l
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int) -> p
    void setColor(float,float,float,float) -> q
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> t
com.badlogic.gdx.graphics.Pixmap$Blending -> l.l$a:
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> f
    com.badlogic.gdx.graphics.Pixmap$Blending None -> d
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> e
com.badlogic.gdx.graphics.Pixmap$Filter -> l.l$b:
    com.badlogic.gdx.graphics.Pixmap$Filter[] $VALUES -> f
    com.badlogic.gdx.graphics.Pixmap$Filter NearestNeighbour -> d
    com.badlogic.gdx.graphics.Pixmap$Filter BiLinear -> e
com.badlogic.gdx.graphics.Pixmap$Format -> l.l$c:
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> k
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> d
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> e
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> g
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> h
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> i
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> j
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.PixmapIO -> l.m:
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$CIM -> l.m$a:
    byte[] readBuffer -> b
    byte[] writeBuffer -> a
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.Texture -> l.n:
    java.util.Map managedTextures -> j
    com.badlogic.gdx.graphics.TextureData data -> i
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> P
    void clearAllTextures(com.badlogic.gdx.Application) -> Q
    int getHeight() -> R
    java.lang.String getManagedStatus() -> S
    com.badlogic.gdx.graphics.TextureData getTextureData() -> T
    int getWidth() -> U
    void invalidateAllTextures(com.badlogic.gdx.Application) -> V
    boolean isManaged() -> W
    void load(com.badlogic.gdx.graphics.TextureData) -> X
    void reload() -> Y
com.badlogic.gdx.graphics.Texture$TextureFilter -> l.n$a:
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> k
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> j
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> i
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> l
    int getGLEnum() -> a
    boolean isMipMap() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> l.n$b:
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> h
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> g
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureArray -> l.o:
    com.badlogic.gdx.graphics.TextureArrayData data -> i
    java.util.Map managedTextureArrays -> j
    void clearAllTextureArrays(com.badlogic.gdx.Application) -> P
    void invalidateAllTextureArrays(com.badlogic.gdx.Application) -> Q
    boolean isManaged() -> R
    void load(com.badlogic.gdx.graphics.TextureArrayData) -> S
    void reload() -> T
com.badlogic.gdx.graphics.TextureArrayData -> l.p:
    int getWidth() -> a
    int getHeight() -> b
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    int getGLType() -> f
    int getInternalFormat() -> g
    void consumeTextureArrayData() -> h
com.badlogic.gdx.graphics.TextureData -> l.q:
    int getWidth() -> a
    int getHeight() -> b
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    boolean disposePixmap() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.TextureData$Factory -> l.q$a:
    com.badlogic.gdx.graphics.TextureData loadFromFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap$Format,boolean) -> a
com.badlogic.gdx.graphics.TextureData$TextureDataType -> l.q$b:
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> f
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> d
com.badlogic.gdx.graphics.VertexAttribute -> l.r:
    java.lang.String alias -> f
    int usageIndex -> h
    int unit -> g
    int type -> d
    int offset -> e
    int numComponents -> b
    boolean normalized -> c
    int usage -> a
    boolean equals(com.badlogic.gdx.graphics.VertexAttribute) -> a
    int getKey() -> b
    int getSizeInBytes() -> c
com.badlogic.gdx.graphics.VertexAttributes -> l.s:
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> d
    long mask -> f
    int textureCoordinates -> h
    int boneWeightUnits -> g
    int vertexSize -> e
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable iterable -> i
    int calculateOffsets() -> a
    int compareTo(com.badlogic.gdx.graphics.VertexAttributes) -> b
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> c
    long getMask() -> d
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable -> l.s$a:
    java.lang.Object[] array -> d
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator2 -> f
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator1 -> e
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator -> l.s$b:
    java.lang.Object[] array -> d
    boolean valid -> f
    int index -> e
com.badlogic.gdx.graphics.g2d.Batch -> m.a:
    void setColor(com.badlogic.gdx.graphics.Color) -> D
    com.badlogic.gdx.graphics.Color getColor() -> E
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> G
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> N
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> h
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> i
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> k
    void begin() -> o
    void setColor(float,float,float,float) -> q
    void setPackedColor(float) -> u
    float getPackedColor() -> v
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> x
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.BitmapFont -> m.b:
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    boolean integer -> e
    boolean ownsTexture -> f
    com.badlogic.gdx.utils.Array regions -> b
    boolean flipped -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData getData() -> A
    float getDescent() -> C
    com.badlogic.gdx.graphics.Color getColor() -> E
    com.badlogic.gdx.utils.Array getRegions() -> F
    float getScaleX() -> J
    float getScaleY() -> K
    boolean isFlipped() -> M
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> O
    com.badlogic.gdx.graphics.g2d.BitmapFontCache newFontCache() -> P
    void setOwnsTexture(boolean) -> Q
    void setUseIntegerPositions(boolean) -> R
    boolean usesIntegerPositions() -> S
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float,int,int,float,int,boolean) -> l
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> p
    void setColor(float,float,float,float) -> q
    float getCapHeight() -> t
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> m.b$a:
    float ascent -> k
    float lineHeight -> i
    com.badlogic.gdx.files.FileHandle fontFile -> c
    float padBottom -> g
    float padTop -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph missingGlyph -> t
    char[] capChars -> y
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> s
    boolean markupEnabled -> q
    float spaceXadvance -> u
    char[] xChars -> x
    java.lang.String name -> a
    float scaleX -> o
    boolean flipped -> d
    float down -> m
    float descent -> l
    float capHeight -> j
    float padLeft -> h
    float padRight -> f
    java.lang.String[] imagePaths -> b
    float xHeight -> v
    char[] breakChars -> w
    float cursorX -> r
    float scaleY -> p
    float blankLineScale -> n
    int getWrapIndex(com.badlogic.gdx.utils.Array,int) -> A
    boolean hasGlyph(char) -> C
    boolean isBreakChar(char) -> F
    boolean isWhitespace(char) -> J
    void load(com.badlogic.gdx.files.FileHandle,boolean) -> K
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> M
    void setGlyphRegion(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.TextureRegion) -> O
    void setScale(float) -> P
    void setScale(float,float) -> Q
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> l
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> p
    void getGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> t
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> m.b$b:
    boolean fixedWidth -> n
    int page -> o
    int xadvance -> l
    float v2 -> i
    float u2 -> h
    int xoffset -> j
    float v -> g
    int yoffset -> k
    float u -> f
    int width -> d
    int height -> e
    int srcX -> b
    int srcY -> c
    byte[][] kerning -> m
    int id -> a
    int getKerning(char) -> a
    void setKerning(int,int) -> b
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> m.c:
    float currentTint -> i
    float y -> g
    com.badlogic.gdx.graphics.Color color -> h
    float x -> f
    com.badlogic.gdx.utils.IntArray[] pageGlyphIndices -> l
    int glyphCount -> e
    com.badlogic.gdx.utils.Array pooledLayouts -> d
    com.badlogic.gdx.utils.Array layouts -> c
    com.badlogic.gdx.graphics.Color tempColor -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[][] pageVertices -> j
    boolean integer -> b
    int[] idx -> k
    int[] tempGlyphCount -> m
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean) -> b
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> c
    void addText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> d
    void addToCache(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> e
    void clear() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> g
    com.badlogic.gdx.graphics.Color getColor() -> h
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> i
    void requireGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> j
    void requirePageGlyphs(int,int) -> k
    void setPageCount(int) -> l
    void setPosition(float,float) -> m
    void setText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> n
    void setUseIntegerPositions(boolean) -> o
    void tint(com.badlogic.gdx.graphics.Color) -> p
    void translate(float,float) -> q
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long[] nativeData -> f
    long basePtr -> a
    java.nio.ByteBuffer pixelPtr -> e
    int format -> d
    int width -> b
    int height -> c
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> A
    int getFormat() -> C
    java.lang.String getFormatString(int) -> F
    int getGLFormat() -> J
    int getGLInternalFormat() -> K
    int getGLType() -> M
    int getHeight() -> O
    int getPixel(int,int) -> P
    java.nio.ByteBuffer getPixels() -> Q
    int getWidth() -> R
    void setBlend(int) -> S
    void setPixel(int,int,int) -> T
    int toGlFormat(int) -> U
    int toGlType(int) -> V
    void dispose() -> b
    void clear(int) -> l
    void convert(int) -> p
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> t
com.badlogic.gdx.graphics.g2d.GlyphLayout -> m.d:
    com.badlogic.gdx.utils.Array runs -> a
    com.badlogic.gdx.utils.IntArray colors -> b
    float height -> e
    float width -> d
    int glyphCount -> c
    com.badlogic.gdx.utils.Pool glyphRunPool -> f
    com.badlogic.gdx.utils.IntArray colorStack -> g
    void alignRuns(float,int) -> a
    void calculateWidths(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> b
    float getGlyphWidth(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> c
    float getLineOffset(com.badlogic.gdx.utils.Array,com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> d
    int parseColorMarkup(java.lang.CharSequence,int,int) -> e
    void setLastGlyphXAdvance(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> f
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence) -> g
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.Color,float,int,boolean,java.lang.String) -> h
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,com.badlogic.gdx.graphics.Color,float,int,boolean) -> i
    void truncate(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,float,java.lang.String) -> j
    com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun wrap(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,int) -> k
com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun -> m.d$a:
    com.badlogic.gdx.utils.Array glyphs -> a
    float width -> e
    float y -> d
    float x -> c
    com.badlogic.gdx.utils.FloatArray xAdvances -> b
    void appendRun(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> a
com.badlogic.gdx.graphics.g2d.NinePatch -> m.e:
    float rightWidth -> l
    float leftWidth -> k
    int topRight -> j
    int topLeft -> h
    int topCenter -> i
    int middleCenter -> f
    int middleRight -> g
    int bottomRight -> d
    int middleLeft -> e
    int bottomLeft -> b
    int bottomCenter -> c
    com.badlogic.gdx.graphics.Texture texture -> a
    float padBottom -> w
    com.badlogic.gdx.graphics.Color tmpDrawColor -> x
    float padTop -> v
    float padRight -> u
    float padLeft -> t
    float bottomHeight -> p
    float[] vertices -> q
    int idx -> r
    float topHeight -> o
    float middleHeight -> n
    com.badlogic.gdx.graphics.Color color -> s
    float middleWidth -> m
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> b
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> c
    float getBottomHeight() -> d
    float getLeftWidth() -> e
    float getPadBottom() -> f
    float getPadLeft() -> g
    float getPadRight() -> h
    float getPadTop() -> i
    float getRightWidth() -> j
    float getTopHeight() -> k
    float getTotalHeight() -> l
    float getTotalWidth() -> m
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> n
    void prepareVertices(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> o
    void scale(float,float) -> p
    void set(int,float,float,float,float,float) -> q
    void setPadding(float,float,float,float) -> r
com.badlogic.gdx.graphics.g2d.PixmapPacker -> m.f:
    boolean stripWhitespaceY -> i
    int alphaThreshold -> j
    com.badlogic.gdx.graphics.Pixmap$Format pageFormat -> e
    com.badlogic.gdx.graphics.Color transparentColor -> k
    int padding -> f
    java.util.regex.Pattern indexPattern -> o
    int pageHeight -> d
    int pageWidth -> c
    com.badlogic.gdx.utils.Array pages -> l
    com.badlogic.gdx.graphics.g2d.PixmapPacker$PackStrategy packStrategy -> m
    boolean duplicateBorder -> g
    boolean stripWhitespaceX -> h
    com.badlogic.gdx.graphics.Color c -> n
    boolean packToTexture -> a
    boolean disposed -> b
    int getSplitPoint(com.badlogic.gdx.graphics.Pixmap,int,int,boolean,boolean) -> A
    int[] getSplits(com.badlogic.gdx.graphics.Pixmap) -> C
    com.badlogic.gdx.graphics.Color getTransparentColor() -> F
    com.badlogic.gdx.math.Rectangle pack(java.lang.String,com.badlogic.gdx.graphics.Pixmap) -> J
    com.badlogic.gdx.math.Rectangle pack(com.badlogic.gdx.graphics.Pixmap) -> K
    void setPackToTexture(boolean) -> M
    void setTransparentColor(com.badlogic.gdx.graphics.Color) -> O
    void updatePageTextures(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> P
    void updateTextureRegions(com.badlogic.gdx.utils.Array,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> Q
    int[] getPads(com.badlogic.gdx.graphics.Pixmap,int[]) -> l
    com.badlogic.gdx.utils.Array getPages() -> p
    com.badlogic.gdx.math.Rectangle getRect(java.lang.String) -> t
com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy -> m.f$a:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page pack(com.badlogic.gdx.graphics.g2d.PixmapPacker,java.lang.String,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node insert(com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node,com.badlogic.gdx.math.Rectangle) -> b
com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$GuillotinePage -> m.f$a$a:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node root -> f
com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node -> m.f$a$b:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node leftChild -> a
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node rightChild -> b
    com.badlogic.gdx.math.Rectangle rect -> c
    boolean full -> d
com.badlogic.gdx.graphics.g2d.PixmapPacker$PackStrategy -> m.f$b:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page pack(com.badlogic.gdx.graphics.g2d.PixmapPacker,java.lang.String,com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$Page -> m.f$c:
    com.badlogic.gdx.graphics.Pixmap image -> b
    boolean dirty -> e
    com.badlogic.gdx.utils.OrderedMap rects -> a
    com.badlogic.gdx.utils.Array addedRects -> d
    com.badlogic.gdx.graphics.Texture texture -> c
    boolean updateTexture(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$Page$1 -> m.f$c$a:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page this$0 -> k
com.badlogic.gdx.graphics.g2d.PixmapPacker$PixmapPackerRectangle -> m.f$d:
    int originalWidth -> n
    int originalHeight -> o
    int offsetX -> l
    int offsetY -> m
    int[] splits -> j
    int[] pads -> k
com.badlogic.gdx.graphics.g2d.PixmapPacker$SkylineStrategy -> m.f$e:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page pack(com.badlogic.gdx.graphics.g2d.PixmapPacker,java.lang.String,com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$SkylineStrategy$SkylinePage -> m.f$e$a:
    com.badlogic.gdx.utils.Array rows -> f
com.badlogic.gdx.graphics.g2d.PixmapPacker$SkylineStrategy$SkylinePage$Row -> m.f$e$a$a:
    int y -> b
    int height -> c
    int x -> a
com.badlogic.gdx.graphics.g2d.Sprite -> m.g:
    float width -> l
    float y -> k
    float x -> j
    com.badlogic.gdx.graphics.Color color -> i
    float[] vertices -> h
    float scaleY -> r
    float scaleX -> q
    float rotation -> p
    float originY -> o
    float originX -> n
    boolean dirty -> s
    float height -> m
    void setColor(float,float,float,float) -> A
    void setColor(com.badlogic.gdx.graphics.Color) -> B
    void setOrigin(float,float) -> C
    void setPackedColor(float) -> D
    void setRotation(float) -> E
    void setScale(float,float) -> F
    void setSize(float,float) -> G
    void translate(float,float) -> H
    void flip(boolean,boolean) -> a
    void setRegion(float,float,float,float) -> k
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> o
    com.badlogic.gdx.graphics.Color getColor() -> p
    float getHeight() -> q
    float getOriginX() -> r
    float getOriginY() -> s
    float[] getVertices() -> t
    float getWidth() -> u
    float getX() -> v
    float getY() -> w
    void rotate90(boolean) -> x
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> y
    void setBounds(float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.SpriteBatch -> m.h:
    int blendSrcFuncAlpha -> n
    int blendDstFuncAlpha -> o
    int blendSrcFunc -> l
    int blendDstFunc -> m
    float invTexHeight -> f
    boolean blendingDisabled -> k
    float invTexWidth -> e
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> p
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> q
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> i
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> j
    float[] vertices -> b
    int idx -> c
    boolean ownsShader -> r
    com.badlogic.gdx.graphics.Mesh mesh -> a
    com.badlogic.gdx.graphics.Texture lastTexture -> d
    com.badlogic.gdx.math.Matrix4 transformMatrix -> h
    float colorPacked -> t
    int totalRenderCalls -> v
    int maxSpritesInBatch -> w
    boolean drawing -> g
    com.badlogic.gdx.graphics.Mesh$VertexDataType defaultVertexDataType -> x
    int renderCalls -> u
    com.badlogic.gdx.graphics.Color color -> s
    void setupMatrices() -> A
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> C
    void setColor(com.badlogic.gdx.graphics.Color) -> D
    com.badlogic.gdx.graphics.Color getColor() -> E
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> G
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> N
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> h
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> i
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> k
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> l
    void begin() -> o
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float) -> p
    void setColor(float,float,float,float) -> q
    boolean isBlendingEnabled() -> t
    void setPackedColor(float) -> u
    float getPackedColor() -> v
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> x
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.TextureAtlas -> m.i:
    com.badlogic.gdx.utils.ObjectSet textures -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String) -> l
    com.badlogic.gdx.utils.Array getRegions() -> p
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> t
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> m.i$a:
    int originalWidth -> n
    int[][] values -> s
    float offsetY -> k
    int originalHeight -> o
    java.lang.String name -> i
    float offsetX -> j
    int packedWidth -> l
    int packedHeight -> m
    boolean rotate -> p
    int index -> h
    int degrees -> q
    java.lang.String[] names -> r
    void flip(boolean,boolean) -> a
    int[] findValue(java.lang.String) -> o
    float getRotatedPackedHeight() -> p
    float getRotatedPackedWidth() -> q
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> m.i$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> t
    float originalOffsetY -> v
    float originalOffsetX -> u
    void setOrigin(float,float) -> C
    void setSize(float,float) -> G
    float getHeightRatio() -> I
    float getWidthRatio() -> J
    void flip(boolean,boolean) -> a
    float getHeight() -> q
    float getOriginX() -> r
    float getOriginY() -> s
    float getWidth() -> u
    float getX() -> v
    float getY() -> w
    void setBounds(float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> m.i$c:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle,boolean) -> a
    int readEntry(java.lang.String[],java.lang.String) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$1 -> m.i$c$f:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$10 -> m.i$c$a:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$11 -> m.i$c$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$12 -> m.i$c$c:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$13 -> m.i$c$d:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> c
    boolean[] val$hasIndexes -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$14 -> m.i$c$e:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> a
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$2 -> m.i$c$g:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$3 -> m.i$c$h:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$4 -> m.i$c$i:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$5 -> m.i$c$j:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$6 -> m.i$c$k:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$7 -> m.i$c$l:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$8 -> m.i$c$m:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$9 -> m.i$c$n:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Field -> m.i$c$o:
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> m.i$c$p:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    boolean pma -> k
    com.badlogic.gdx.graphics.Pixmap$Format format -> f
    float height -> d
    boolean useMipMaps -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> j
    float width -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> g
    com.badlogic.gdx.graphics.Texture texture -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> m.i$c$q:
    int index -> m
    boolean flip -> p
    float offsetY -> h
    int originalHeight -> j
    float offsetX -> g
    int degrees -> k
    int originalWidth -> i
    boolean rotate -> l
    int height -> f
    int top -> d
    int width -> e
    int left -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    java.lang.String[] names -> n
    int[][] values -> o
    java.lang.String name -> b
com.badlogic.gdx.graphics.g2d.TextureRegion -> m.j:
    float v2 -> e
    float u2 -> d
    int regionWidth -> f
    float v -> c
    int regionHeight -> g
    float u -> b
    com.badlogic.gdx.graphics.Texture texture -> a
    void flip(boolean,boolean) -> a
    int getRegionHeight() -> b
    int getRegionWidth() -> c
    int getRegionX() -> d
    int getRegionY() -> e
    com.badlogic.gdx.graphics.Texture getTexture() -> f
    float getU() -> g
    float getU2() -> h
    float getV() -> i
    float getV2() -> j
    void setRegion(float,float,float,float) -> k
    void setRegion(int,int,int,int) -> l
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> m
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> n
com.badlogic.gdx.graphics.g2d.freetype.FreeType -> com.badlogic.gdx.graphics.g2d.freetype.FreeType:
    int FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH -> O
    int FT_ENCODING_ADOBE_CUSTOM -> l
    int FT_LOAD_VERTICAL_LAYOUT -> K
    int FT_ENCODING_WANSUNG -> h
    int FT_LOAD_NO_SCALE -> G
    int FT_ENCODING_UNICODE -> d
    int FT_FACE_FLAG_TRICKY -> C
    int FT_LOAD_TARGET_LCD -> X
    int FT_FACE_FLAG_GLYPH_NAMES -> y
    int FT_LOAD_NO_AUTOHINT -> T
    int FT_FACE_FLAG_VERTICAL -> u
    int FT_LOAD_NO_RECURSE -> P
    int FT_FACE_FLAG_FIXED_SIZES -> q
    int FT_RENDER_MODE_LCD_V -> d0
    int FT_LOAD_FORCE_AUTOHINT -> L
    int FT_RENDER_MODE_MONO -> b0
    int FT_ENCODING_ADOBE_LATIN_1 -> m
    int FT_KERNING_UNSCALED -> h0
    int FT_LOAD_NO_HINTING -> H
    int FT_KERNING_DEFAULT -> f0
    int FT_ENCODING_JOHAB -> i
    int FT_STROKER_LINEJOIN_ROUND -> l0
    int FT_STYLE_FLAG_ITALIC -> D
    int FT_STROKER_LINECAP_ROUND -> j0
    int FT_ENCODING_SJIS -> e
    int FT_STROKER_LINEJOIN_MITER_FIXED -> p0
    int FT_STROKER_LINEJOIN_MITER_VARIABLE -> n0
    int FT_PIXEL_MODE_MONO -> a
    int FT_FACE_FLAG_EXTERNAL_STREAM -> z
    int FT_LOAD_TARGET_LCD_V -> Y
    int FT_FACE_FLAG_KERNING -> v
    int FT_LOAD_TARGET_NORMAL -> U
    int FT_FACE_FLAG_FIXED_WIDTH -> r
    int FT_LOAD_IGNORE_TRANSFORM -> Q
    int FT_ENCODING_OLD_LATIN_2 -> n
    int FT_LOAD_CROP_BITMAP -> M
    int FT_ENCODING_ADOBE_STANDARD -> j
    int FT_LOAD_RENDER -> I
    int FT_ENCODING_GB2312 -> f
    int FT_STYLE_FLAG_BOLD -> E
    int FT_PIXEL_MODE_GRAY -> b
    int FT_FACE_FLAG_HINTER -> A
    int FT_RENDER_MODE_NORMAL -> Z
    int FT_LOAD_TARGET_LIGHT -> V
    int FT_FACE_FLAG_FAST_GLYPHS -> w
    int FT_LOAD_MONOCHROME -> R
    int FT_FACE_FLAG_SFNT -> s
    int FT_LOAD_PEDANTIC -> N
    int FT_ENCODING_APPLE_ROMAN -> o
    int FT_RENDER_MODE_LCD -> c0
    int FT_RENDER_MODE_LIGHT -> a0
    int FT_LOAD_NO_BITMAP -> J
    int FT_ENCODING_ADOBE_EXPERT -> k
    int FT_KERNING_UNFITTED -> g0
    int FT_RENDER_MODE_MAX -> e0
    int FT_LOAD_DEFAULT -> F
    int FT_ENCODING_BIG5 -> g
    int FT_STROKER_LINECAP_SQUARE -> k0
    int FT_STROKER_LINECAP_BUTT -> i0
    int FT_FACE_FLAG_CID_KEYED -> B
    int FT_ENCODING_MS_SYMBOL -> c
    int FT_STROKER_LINEJOIN_MITER -> o0
    int FT_STROKER_LINEJOIN_BEVEL -> m0
    int FT_FACE_FLAG_MULTIPLE_MASTERS -> x
    int FT_LOAD_TARGET_MONO -> W
    int FT_FACE_FLAG_HORIZONTAL -> t
    int FT_LOAD_LINEAR_DESIGN -> S
    int FT_FACE_FLAG_SCALABLE -> p
    int encode(char,char,char,char) -> a
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Library initFreeType() -> b
    int toInt(int) -> c
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Bitmap -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$Bitmap:
    com.badlogic.gdx.graphics.Pixmap getPixmap(com.badlogic.gdx.graphics.Pixmap$Format,com.badlogic.gdx.graphics.Color,float) -> A
    int getRows() -> C
    int getWidth() -> F
    java.nio.ByteBuffer getBuffer() -> l
    int getPitch() -> p
    int getPixelMode() -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Face -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$Face:
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Library library -> b
    int getKerning(int,int,int) -> A
    int getMaxAdvanceWidth() -> C
    int getNumGlyphs() -> F
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Size getSize() -> J
    boolean hasKerning() -> K
    boolean loadChar(int,int) -> M
    boolean setPixelSizes(int,int) -> O
    void dispose() -> b
    int getCharIndex(int) -> l
    int getFaceFlags() -> p
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$GlyphSlot getGlyph() -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Glyph -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$Glyph:
    boolean rendered -> b
    void strokeBorder(com.badlogic.gdx.graphics.g2d.freetype.FreeType$Stroker,boolean) -> A
    void toBitmap(int) -> C
    void dispose() -> b
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Bitmap getBitmap() -> l
    int getLeft() -> p
    int getTop() -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeType$GlyphMetrics -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$GlyphMetrics:
    int getHeight() -> l
    int getHoriAdvance() -> p
com.badlogic.gdx.graphics.g2d.freetype.FreeType$GlyphSlot -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$GlyphSlot:
    int getFormat() -> l
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Glyph getGlyph() -> p
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$GlyphMetrics getMetrics() -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Library -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$Library:
    com.badlogic.gdx.utils.LongMap fontData -> b
    void dispose() -> b
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Stroker createStroker() -> l
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Face newFace(com.badlogic.gdx.files.FileHandle,int) -> p
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Face newMemoryFace(java.nio.ByteBuffer,int) -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Pointer -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$a:
    long address -> a
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Size -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$Size:
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$SizeMetrics getMetrics() -> l
com.badlogic.gdx.graphics.g2d.freetype.FreeType$SizeMetrics -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$SizeMetrics:
    int getAscender() -> l
    int getDescender() -> p
    int getHeight() -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeType$Stroker -> com.badlogic.gdx.graphics.g2d.freetype.FreeType$Stroker:
    void dispose() -> b
    void set(int,int,int,int) -> l
com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator -> com.badlogic.gdx.graphics.g2d.freetype.a:
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Library library -> a
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Face face -> b
    int pixelHeight -> f
    int maxTextureSize -> g
    int pixelWidth -> e
    java.lang.String name -> c
    boolean bitmapped -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont generateFont(com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter) -> A
    com.badlogic.gdx.graphics.g2d.BitmapFont generateFont(com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter,com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeBitmapFontData) -> C
    int getLoadingFlags(com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter) -> F
    boolean loadChar(int) -> J
    boolean loadChar(int,int) -> K
    com.badlogic.gdx.graphics.g2d.BitmapFont newBitmapFont(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.utils.Array,boolean) -> M
    void setMaxTextureSize(int) -> O
    void setPixelSizes(int,int) -> P
    void dispose() -> b
    boolean checkForBitmapFont() -> l
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph createGlyph(char,com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeBitmapFontData,com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter,com.badlogic.gdx.graphics.g2d.freetype.FreeType$Stroker,float,com.badlogic.gdx.graphics.g2d.PixmapPacker) -> p
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeBitmapFontData generateData(com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter,com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeBitmapFontData) -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$1 -> com.badlogic.gdx.graphics.g2d.freetype.a$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$freetype$FreeTypeFontGenerator$Hinting -> a
com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeBitmapFontData -> com.badlogic.gdx.graphics.g2d.freetype.a$b:
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator generator -> A
    com.badlogic.gdx.utils.Array regions -> z
    com.badlogic.gdx.graphics.g2d.freetype.FreeType$Stroker stroker -> C
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter parameter -> B
    com.badlogic.gdx.utils.Array glyphs -> E
    boolean dirty -> F
    com.badlogic.gdx.graphics.g2d.PixmapPacker packer -> D
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> p
    void getGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> t
com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$FreeTypeFontParameter -> com.badlogic.gdx.graphics.g2d.freetype.a$c:
    int spaceX -> n
    com.badlogic.gdx.graphics.Color color -> d
    int shadowOffsetY -> l
    boolean borderStraight -> i
    float borderWidth -> g
    com.badlogic.gdx.graphics.Color borderColor -> h
    float gamma -> e
    int renderCount -> f
    boolean kerning -> u
    boolean flip -> w
    java.lang.String characters -> t
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting hinting -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> y
    boolean incremental -> A
    boolean mono -> b
    int padRight -> s
    int padLeft -> q
    int spaceY -> o
    float borderGamma -> j
    int shadowOffsetX -> k
    boolean genMipMaps -> x
    int size -> a
    com.badlogic.gdx.graphics.Color shadowColor -> m
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> z
    com.badlogic.gdx.graphics.g2d.PixmapPacker packer -> v
    int padBottom -> r
    int padTop -> p
com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting -> com.badlogic.gdx.graphics.g2d.freetype.a$d:
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting Medium -> f
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting Slight -> e
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting None -> d
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting AutoFull -> j
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting AutoMedium -> i
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting AutoSlight -> h
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting Full -> g
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator$Hinting[] $VALUES -> k
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int ETC1_RGB8_OES -> b
    int PKM_HEADER_SIZE -> a
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.ETC1$a:
    int dataOffset -> d
    java.nio.ByteBuffer compressedData -> c
    int height -> b
    int width -> a
    void dispose() -> b
    void checkNPOT() -> l
    boolean hasPKMHeader() -> p
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.a:
    com.badlogic.gdx.files.FileHandle file -> a
    boolean isPrepared -> f
    int width -> d
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    int height -> e
    boolean useMipMaps -> c
    int getWidth() -> a
    int getHeight() -> b
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    boolean disposePixmap() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.glutils.FileTextureData -> n.a:
    com.badlogic.gdx.graphics.Pixmap pixmap -> e
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.Pixmap$Format format -> d
    boolean useMipMaps -> f
    boolean isPrepared -> g
    int width -> b
    int height -> c
    int getWidth() -> a
    int getHeight() -> b
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    boolean disposePixmap() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.glutils.GLFrameBuffer -> n.b:
    java.util.Map buffers -> c
    com.badlogic.gdx.utils.Array textureAttachments -> a
    boolean defaultFramebufferHandleInitialized -> e
    int defaultFramebufferHandle -> d
    int framebufferHandle -> b
    java.lang.String getManagedStatus() -> A
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> C
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> F
    void build() -> l
    void checkValidBuilder() -> p
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> t
com.badlogic.gdx.graphics.glutils.GLVersion -> n.c:
    java.lang.String TAG -> g
    int minorVersion -> b
    int releaseVersion -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type type -> f
    java.lang.String rendererString -> e
    int majorVersion -> a
    java.lang.String vendorString -> d
    void extractVersion(java.lang.String,java.lang.String) -> a
    int getMajorVersion() -> b
    int parseInt(java.lang.String,int) -> c
com.badlogic.gdx.graphics.glutils.GLVersion$Type -> n.c$a:
    com.badlogic.gdx.graphics.glutils.GLVersion$Type GLES -> e
    com.badlogic.gdx.graphics.glutils.GLVersion$Type OpenGL -> d
    com.badlogic.gdx.graphics.glutils.GLVersion$Type[] $VALUES -> h
    com.badlogic.gdx.graphics.glutils.GLVersion$Type NONE -> g
    com.badlogic.gdx.graphics.glutils.GLVersion$Type WebGL -> f
com.badlogic.gdx.graphics.glutils.HdpiMode -> n.d:
    com.badlogic.gdx.graphics.glutils.HdpiMode[] $VALUES -> f
    com.badlogic.gdx.graphics.glutils.HdpiMode Pixels -> e
    com.badlogic.gdx.graphics.glutils.HdpiMode Logical -> d
com.badlogic.gdx.graphics.glutils.HdpiUtils -> n.e:
    com.badlogic.gdx.graphics.glutils.HdpiMode mode -> a
    void glScissor(int,int,int,int) -> a
    void glViewport(int,int,int,int) -> b
    int toBackBufferX(int) -> c
    int toBackBufferY(int) -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> n.g:
    int getNumVertices() -> e
    void color(float) -> f
    void vertex(float,float,float) -> g
    void begin(com.badlogic.gdx.math.Matrix4,int) -> h
    int getMaxVertices() -> i
    void color(float,float,float,float) -> j
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> n.f:
    int colorOffset -> l
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> g
    int texCoordOffset -> m
    int vertexSize -> j
    int normalOffset -> k
    int numTexCoords -> i
    int maxVertices -> d
    int numVertices -> e
    com.badlogic.gdx.graphics.Mesh mesh -> f
    int vertexIdx -> b
    int numSetTexCoords -> c
    int primitiveType -> a
    com.badlogic.gdx.math.Matrix4 projModelView -> n
    boolean ownsShader -> h
    java.lang.String[] shaderUniformNames -> p
    float[] vertices -> o
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> a
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> b
    java.lang.String createFragmentShader(boolean,boolean,int) -> c
    java.lang.String createVertexShader(boolean,boolean,int) -> d
    int getNumVertices() -> e
    void color(float) -> f
    void vertex(float,float,float) -> g
    void begin(com.badlogic.gdx.math.Matrix4,int) -> h
    int getMaxVertices() -> i
    void color(float,float,float,float) -> j
    void flush() -> k
com.badlogic.gdx.graphics.glutils.IndexArray -> n.h:
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    boolean empty -> c
    java.nio.ShortBuffer getBuffer(boolean) -> H
    void bind() -> I
    void setIndices(short[],int,int) -> L
    void invalidate() -> f
    int getNumMaxIndices() -> m
    int getNumIndices() -> s
    void unbind() -> w
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> n.i:
    boolean empty -> i
    int usage -> h
    boolean isDirect -> e
    boolean isDirty -> f
    java.nio.ShortBuffer buffer -> a
    int bufferHandle -> d
    boolean isBound -> g
    java.nio.ByteBuffer byteBuffer -> b
    boolean ownsBuffer -> c
    java.nio.ShortBuffer getBuffer(boolean) -> H
    void bind() -> I
    void setIndices(short[],int,int) -> L
    void invalidate() -> f
    int getNumMaxIndices() -> m
    int getNumIndices() -> s
    void unbind() -> w
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> n.j:
    boolean isDirty -> e
    boolean isBound -> f
    int usage -> g
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    int bufferHandle -> c
    boolean isDirect -> d
    java.nio.ShortBuffer getBuffer(boolean) -> H
    void bind() -> I
    void setIndices(short[],int,int) -> L
    void invalidate() -> f
    int createBufferObject() -> l
    int getNumMaxIndices() -> m
    int getNumIndices() -> s
    void unbind() -> w
com.badlogic.gdx.graphics.glutils.IndexData -> n.k:
    java.nio.ShortBuffer getBuffer(boolean) -> H
    void bind() -> I
    void setIndices(short[],int,int) -> L
    void invalidate() -> f
    int getNumMaxIndices() -> m
    int getNumIndices() -> s
    void unbind() -> w
com.badlogic.gdx.graphics.glutils.InstanceData -> n.l:
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    int getNumInstances() -> j
com.badlogic.gdx.graphics.glutils.KTXTextureData -> com.badlogic.gdx.graphics.glutils.b:
    java.nio.ByteBuffer compressedData -> n
    com.badlogic.gdx.files.FileHandle file -> a
    int numberOfMipmapLevels -> l
    boolean useMipMaps -> o
    int imagePos -> m
    int numberOfArrayElements -> j
    int numberOfFaces -> k
    int pixelHeight -> h
    int pixelDepth -> i
    int glBaseInternalFormat -> f
    int pixelWidth -> g
    int glFormat -> d
    int glInternalFormat -> e
    int glType -> b
    int glTypeSize -> c
    int getWidth() -> a
    int getHeight() -> b
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    void consumeCubemapData() -> g
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    boolean disposePixmap() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
    void disposePreparedData() -> m
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> n.m:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> d
com.badlogic.gdx.graphics.glutils.PixmapTextureData -> n.n:
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    boolean managed -> e
    boolean useMipMaps -> c
    boolean disposePixmap -> d
    int getWidth() -> a
    int getHeight() -> b
    boolean isManaged() -> c
    void prepare() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    boolean disposePixmap() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.glutils.ShaderProgram -> n.o:
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> i
    int vertexShaderHandle -> l
    com.badlogic.gdx.utils.ObjectIntMap attributes -> g
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> e
    boolean pedantic -> u
    java.nio.IntBuffer type -> t
    java.lang.String fragmentShaderSource -> p
    boolean invalidated -> q
    java.lang.String prependVertexCode -> v
    java.lang.String[] attributeNames -> j
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> d
    java.lang.String log -> a
    boolean isCompiled -> b
    int fragmentShaderHandle -> m
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> h
    int program -> k
    java.lang.String vertexShaderSource -> o
    java.nio.IntBuffer params -> s
    java.lang.String[] uniformNames -> f
    java.nio.IntBuffer intbuf -> y
    java.lang.String prependFragmentCode -> w
    com.badlogic.gdx.utils.ObjectMap shaders -> x
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> c
    java.nio.FloatBuffer matrix -> n
    int refCount -> r
    void compileShaders(java.lang.String,java.lang.String) -> A
    int createProgram() -> C
    void disableVertexAttribute(int) -> F
    void bind() -> I
    void disableVertexAttribute(java.lang.String) -> J
    void enableVertexAttribute(int) -> K
    int fetchAttributeLocation(java.lang.String) -> M
    void fetchAttributes() -> O
    int fetchUniformLocation(java.lang.String) -> P
    int fetchUniformLocation(java.lang.String,boolean) -> Q
    void fetchUniforms() -> R
    int getAttributeLocation(java.lang.String) -> S
    java.lang.String getLog() -> T
    java.lang.String getManagedStatus() -> U
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> V
    boolean isCompiled() -> W
    int linkProgram(int) -> X
    int loadShader(int,java.lang.String) -> Y
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix4,boolean) -> Z
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> a0
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> b0
    void setUniformi(java.lang.String,int) -> c0
    void setVertexAttribute(int,int,int,boolean,int,int) -> d0
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> e0
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> l
    void checkManaged() -> p
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> t
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> n.p:
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.graphics.Color color -> g
    float defaultRectLineWidth -> j
    boolean autoShapeType -> i
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> e
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean matrixDirty -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType shapeType -> h
    com.badlogic.gdx.math.Vector2 tmp -> f
    void rect(float,float,float,float) -> A
    void rect(float,float,float,float,float,float,float,float,float) -> C
    void setColor(com.badlogic.gdx.graphics.Color) -> D
    void rect(float,float,float,float,float,float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> F
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> G
    void set(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> J
    void setAutoShapeType(boolean) -> K
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> N
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> h
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> l
    void begin() -> o
    void check(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,int) -> p
    boolean isDrawing() -> t
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> n.p$a:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> h
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> e
    int glType -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> g
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> f
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> n.q:
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean isBound -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    int getNumVertices() -> e
    void invalidate() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void setVertices(float[],int,int) -> n
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> n.r:
    java.nio.FloatBuffer buffer -> b
    int usage -> f
    boolean isDirty -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isBound -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    int getNumVertices() -> e
    void invalidate() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void bufferChanged() -> l
    void setVertices(float[],int,int) -> n
    void setBuffer(java.nio.Buffer,boolean,com.badlogic.gdx.graphics.VertexAttributes) -> p
    void setUsage(int) -> t
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> n.s:
    java.nio.FloatBuffer buffer -> b
    boolean isBound -> i
    boolean isDirect -> e
    boolean isStatic -> f
    int usage -> g
    int bufferHandle -> d
    java.nio.ByteBuffer byteBuffer -> c
    boolean isDirty -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    int getNumVertices() -> e
    void invalidate() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void bufferChanged() -> l
    void setVertices(float[],int,int) -> n
    int createBufferObject() -> p
com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO -> n.t:
    java.nio.FloatBuffer buffer -> b
    java.nio.IntBuffer tmpHandle -> l
    com.badlogic.gdx.utils.IntArray cachedLocations -> k
    boolean isBound -> i
    int vaoHandle -> j
    boolean isStatic -> f
    int usage -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isDirty -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    void createVAO() -> A
    void unbindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> C
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    int getNumVertices() -> e
    void invalidate() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void bindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> l
    void setVertices(float[],int,int) -> n
    void bindData(com.badlogic.gdx.graphics.GL20) -> p
    void bufferChanged() -> t
com.badlogic.gdx.graphics.glutils.VertexData -> n.u:
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    int getNumVertices() -> e
    void invalidate() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void setVertices(float[],int,int) -> n
com.badlogic.gdx.input.GestureDetector -> o.a:
    long lastTapTime -> i
    float lastTapY -> k
    int lastTapButton -> l
    boolean pinching -> o
    int tapCount -> h
    float longPressSeconds -> e
    float tapRectangleHeight -> c
    com.badlogic.gdx.utils.Timer$Task longPressTask -> y
    float tapRectangleCenterY -> s
    com.badlogic.gdx.math.Vector2 initialPointer2 -> x
    com.badlogic.gdx.math.Vector2 pointer2 -> v
    boolean longPressFired -> n
    float lastTapX -> j
    int lastTapPointer -> m
    boolean panning -> p
    long maxFlingDelay -> f
    float tapRectangleWidth -> b
    long tapCountInterval -> d
    boolean inTapRectangle -> g
    float tapRectangleCenterX -> r
    long touchDownTime -> t
    com.badlogic.gdx.input.GestureDetector$GestureListener listener -> a
    com.badlogic.gdx.input.GestureDetector$VelocityTracker tracker -> q
    com.badlogic.gdx.math.Vector2 initialPointer1 -> w
    com.badlogic.gdx.math.Vector2 pointer1 -> u
    boolean touchDragged(int,int,int) -> M
    void cancel() -> O
    boolean isPanning() -> P
    boolean isWithinTapRectangle(float,float,float,float) -> Q
    void reset() -> R
    boolean touchDown(float,float,int,int) -> S
    boolean touchDragged(float,float,int) -> T
    boolean touchUp(float,float,int,int) -> U
    boolean touchDown(int,int,int,int) -> l
    boolean touchUp(int,int,int,int) -> t
com.badlogic.gdx.input.GestureDetector$1 -> o.a$a:
    com.badlogic.gdx.input.GestureDetector this$0 -> i
com.badlogic.gdx.input.GestureDetector$GestureAdapter -> o.a$b:
    void pinchStop() -> b
    boolean touchDown(float,float,int,int) -> e
com.badlogic.gdx.input.GestureDetector$GestureListener -> o.a$c:
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void pinchStop() -> b
    boolean fling(float,float,int) -> c
    boolean longPress(float,float) -> d
    boolean touchDown(float,float,int,int) -> e
    boolean pan(float,float,float,float) -> f
    boolean panStop(float,float,int,int) -> g
    boolean zoom(float,float) -> h
    boolean tap(float,float,int,int) -> i
com.badlogic.gdx.input.GestureDetector$VelocityTracker -> o.a$d:
    long lastTime -> f
    float[] meanY -> i
    float deltaY -> e
    float[] meanX -> h
    float deltaX -> d
    float lastY -> c
    int numSamples -> g
    float lastX -> b
    int sampleSize -> a
    long[] meanTime -> j
    float getAverage(float[],int) -> a
    long getAverage(long[],int) -> b
    float getVelocityX() -> c
    float getVelocityY() -> d
    void start(float,float,long) -> e
    void update(float,float,long) -> f
com.badlogic.gdx.maps.ImageResolver -> p.a:
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.ImageResolver$DirectImageResolver -> p.a$a:
    com.badlogic.gdx.utils.ObjectMap images -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.Map -> p.b:
    com.badlogic.gdx.maps.MapLayers layers -> a
    com.badlogic.gdx.maps.MapProperties properties -> b
    com.badlogic.gdx.maps.MapLayers getLayers() -> l
    com.badlogic.gdx.maps.MapProperties getProperties() -> p
com.badlogic.gdx.maps.MapGroupLayer -> p.c:
    com.badlogic.gdx.maps.MapLayers layers -> n
    void invalidateRenderOffset() -> i
    com.badlogic.gdx.maps.MapLayers getLayers() -> s
com.badlogic.gdx.maps.MapLayer -> p.d:
    float parallaxY -> i
    float parallaxX -> h
    float renderOffsetY -> g
    boolean renderOffsetDirty -> j
    float renderOffsetX -> f
    float offsetY -> e
    float offsetX -> d
    float opacity -> b
    com.badlogic.gdx.maps.MapLayer parent -> k
    java.lang.String name -> a
    com.badlogic.gdx.maps.MapObjects objects -> l
    com.badlogic.gdx.maps.MapProperties properties -> m
    boolean visible -> c
    void calculateRenderOffsets() -> a
    com.badlogic.gdx.maps.MapObjects getObjects() -> b
    float getOpacity() -> c
    float getParallaxX() -> d
    float getParallaxY() -> e
    com.badlogic.gdx.maps.MapProperties getProperties() -> f
    float getRenderOffsetX() -> g
    float getRenderOffsetY() -> h
    void invalidateRenderOffset() -> i
    boolean isVisible() -> j
    void setName(java.lang.String) -> k
    void setOffsetX(float) -> l
    void setOffsetY(float) -> m
    void setOpacity(float) -> n
    void setParallaxX(float) -> o
    void setParallaxY(float) -> p
    void setParent(com.badlogic.gdx.maps.MapLayer) -> q
    void setVisible(boolean) -> r
com.badlogic.gdx.maps.MapLayers -> p.e:
    com.badlogic.gdx.utils.Array layers -> d
    void add(com.badlogic.gdx.maps.MapLayer) -> a
    com.badlogic.gdx.maps.MapLayer get(int) -> b
    com.badlogic.gdx.utils.Array getByType(java.lang.Class) -> c
    com.badlogic.gdx.utils.Array getByType(java.lang.Class,com.badlogic.gdx.utils.Array) -> d
com.badlogic.gdx.maps.MapObject -> p.f:
    com.badlogic.gdx.graphics.Color color -> e
    com.badlogic.gdx.maps.MapProperties properties -> d
    java.lang.String name -> a
    float opacity -> b
    boolean visible -> c
    com.badlogic.gdx.maps.MapProperties getProperties() -> a
    void setName(java.lang.String) -> b
    void setVisible(boolean) -> c
com.badlogic.gdx.maps.MapObjects -> p.g:
    com.badlogic.gdx.utils.Array objects -> d
    void add(com.badlogic.gdx.maps.MapObject) -> a
com.badlogic.gdx.maps.MapProperties -> p.h:
    com.badlogic.gdx.utils.ObjectMap properties -> a
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> b
    void put(java.lang.String,java.lang.Object) -> c
com.badlogic.gdx.maps.objects.EllipseMapObject -> q.a:
    com.badlogic.gdx.math.Ellipse ellipse -> f
com.badlogic.gdx.maps.objects.PolygonMapObject -> q.b:
    com.badlogic.gdx.math.Polygon polygon -> f
com.badlogic.gdx.maps.objects.PolylineMapObject -> q.c:
    com.badlogic.gdx.math.Polyline polyline -> f
com.badlogic.gdx.maps.objects.RectangleMapObject -> q.d:
    com.badlogic.gdx.math.Rectangle rectangle -> f
com.badlogic.gdx.maps.objects.TextureMapObject -> q.e:
    float rotation -> l
    float scaleY -> k
    float scaleX -> j
    float originY -> i
    float originX -> h
    float y -> g
    float x -> f
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> m
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> d
    void setRotation(float) -> e
    void setScaleX(float) -> f
    void setScaleY(float) -> g
    void setTextureRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> h
    void setX(float) -> i
    void setY(float) -> j
com.badlogic.gdx.maps.tiled.BaseTmxMapLoader -> r.a:
    com.badlogic.gdx.maps.tiled.TiledMap map -> j
    com.badlogic.gdx.utils.XmlReader xml -> b
    int mapWidthInPixels -> h
    com.badlogic.gdx.utils.XmlReader$Element root -> c
    int mapHeightInPixels -> i
    boolean flipY -> e
    int mapTileWidth -> f
    int mapTileHeight -> g
    boolean convertObjectToTileSpace -> d
    void addStaticTiledMapTile(com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.graphics.g2d.TextureRegion,int,float,float) -> b
    void addStaticTiles(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver,com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.utils.Array,java.lang.String,int,int,int,int,int,java.lang.String,int,int,java.lang.String,int,int,com.badlogic.gdx.files.FileHandle) -> c
    void addTileObjectGroup(com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element) -> d
    void addTileProperties(com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element) -> e
    java.lang.Object castProperty(java.lang.String,java.lang.String,java.lang.String) -> f
    com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile createAnimatedTile(com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element,int) -> g
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell createTileLayerCell(boolean,boolean,boolean) -> h
    com.badlogic.gdx.files.FileHandle getRelativeFileHandle(com.badlogic.gdx.files.FileHandle,java.lang.String) -> i
    int[] getTileIds(com.badlogic.gdx.utils.XmlReader$Element,int,int) -> j
    void loadBasicLayerInfo(com.badlogic.gdx.maps.MapLayer,com.badlogic.gdx.utils.XmlReader$Element) -> k
    void loadImageLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> l
    void loadLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> m
    void loadLayerGroup(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> n
    void loadObject(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayer,com.badlogic.gdx.utils.XmlReader$Element) -> o
    void loadObject(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapObjects,com.badlogic.gdx.utils.XmlReader$Element,float) -> p
    void loadObject(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element) -> q
    void loadObjectGroup(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element) -> r
    void loadProperties(com.badlogic.gdx.maps.MapProperties,com.badlogic.gdx.utils.XmlReader$Element) -> s
    void loadTileLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element) -> t
    void loadTileSet(com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> u
    com.badlogic.gdx.maps.tiled.TiledMap loadTiledMap(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.tiled.BaseTmxMapLoader$Parameters,com.badlogic.gdx.maps.ImageResolver) -> v
    int unsignedByteToInt(byte) -> w
com.badlogic.gdx.maps.tiled.BaseTmxMapLoader$Parameters -> r.a$a:
    com.badlogic.gdx.graphics.Texture$TextureFilter textureMinFilter -> b
    boolean flipY -> e
    boolean generateMipMaps -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter textureMagFilter -> c
    boolean convertObjectToTileSpace -> d
com.badlogic.gdx.maps.tiled.TiledMap -> r.b:
    com.badlogic.gdx.maps.tiled.TiledMapTileSets tilesets -> c
    com.badlogic.gdx.utils.Array ownedResources -> d
    void setOwnedResources(com.badlogic.gdx.utils.Array) -> A
    com.badlogic.gdx.maps.tiled.TiledMapTileSets getTileSets() -> t
com.badlogic.gdx.maps.tiled.TiledMapImageLayer -> r.c:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> n
    float y -> p
    float x -> o
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> s
    float getX() -> t
    float getY() -> u
com.badlogic.gdx.maps.tiled.TiledMapRenderer -> r.d:
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> l
com.badlogic.gdx.maps.tiled.TiledMapTile -> r.e:
    float getOffsetX() -> a
    int getId() -> b
    void setOffsetX(float) -> c
    void setId(int) -> d
    com.badlogic.gdx.maps.MapProperties getProperties() -> e
    void setOffsetY(float) -> f
    com.badlogic.gdx.maps.MapObjects getObjects() -> g
    float getOffsetY() -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> i
com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode -> r.e$a:
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode[] $VALUES -> f
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode ALPHA -> e
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode NONE -> d
com.badlogic.gdx.maps.tiled.TiledMapTileLayer -> r.f:
    int width -> n
    int height -> o
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell[][] cells -> r
    int tileWidth -> p
    int tileHeight -> q
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell getCell(int,int) -> s
    int getHeight() -> t
    int getTileHeight() -> u
    int getTileWidth() -> v
    int getWidth() -> w
    void setCell(int,int,com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell) -> x
com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell -> r.f$a:
    com.badlogic.gdx.maps.tiled.TiledMapTile tile -> a
    int rotation -> d
    boolean flipHorizontally -> b
    boolean flipVertically -> c
    boolean getFlipHorizontally() -> a
    boolean getFlipVertically() -> b
    int getRotation() -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile() -> d
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setFlipHorizontally(boolean) -> e
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setFlipVertically(boolean) -> f
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setRotation(int) -> g
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setTile(com.badlogic.gdx.maps.tiled.TiledMapTile) -> h
com.badlogic.gdx.maps.tiled.TiledMapTileSet -> r.g:
    com.badlogic.gdx.maps.MapProperties properties -> f
    com.badlogic.gdx.utils.IntMap tiles -> e
    java.lang.String name -> d
    com.badlogic.gdx.maps.MapProperties getProperties() -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile(int) -> b
    void putTile(int,com.badlogic.gdx.maps.tiled.TiledMapTile) -> c
    void setName(java.lang.String) -> d
com.badlogic.gdx.maps.tiled.TiledMapTileSets -> r.h:
    com.badlogic.gdx.utils.Array tilesets -> d
    void addTileSet(com.badlogic.gdx.maps.tiled.TiledMapTileSet) -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile(int) -> b
com.badlogic.gdx.maps.tiled.TmxMapLoader -> r.i:
    void addStaticTiles(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver,com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.utils.Array,java.lang.String,int,int,int,int,int,java.lang.String,int,int,java.lang.String,int,int,com.badlogic.gdx.files.FileHandle) -> c
    com.badlogic.gdx.utils.Array getDependencyFileHandles(com.badlogic.gdx.files.FileHandle) -> x
    com.badlogic.gdx.maps.tiled.TiledMap load(java.lang.String) -> y
    com.badlogic.gdx.maps.tiled.TiledMap load(java.lang.String,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> z
com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters -> r.i$a:
com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject -> s.a:
    boolean flipHorizontally -> n
    boolean flipVertically -> o
    com.badlogic.gdx.maps.tiled.TiledMapTile tile -> p
com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer -> t.a:
    com.badlogic.gdx.math.Rectangle imageBounds -> e
    float[] vertices -> g
    com.badlogic.gdx.graphics.g2d.Batch batch -> c
    boolean ownsBatch -> f
    float unitScale -> b
    com.badlogic.gdx.maps.tiled.TiledMap map -> a
    com.badlogic.gdx.math.Rectangle viewBounds -> d
    void render() -> A
    void renderImageLayer(com.badlogic.gdx.maps.tiled.TiledMapImageLayer) -> C
    void renderMapLayer(com.badlogic.gdx.maps.MapLayer) -> F
    void renderObject(com.badlogic.gdx.maps.MapObject) -> J
    void renderObjects(com.badlogic.gdx.maps.MapLayer) -> K
    void setView(com.badlogic.gdx.graphics.OrthographicCamera) -> M
    void beginRender() -> p
    void endRender() -> t
com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer -> t.b:
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> l
com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile -> u.a:
    com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile[] frameTiles -> e
    int[] animationIntervals -> f
    long initialTimeOffset -> i
    com.badlogic.gdx.maps.MapObjects objects -> d
    long lastTiledMapRenderTime -> h
    int loopDuration -> g
    com.badlogic.gdx.maps.MapProperties properties -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode blendMode -> b
    int id -> a
    float getOffsetX() -> a
    int getId() -> b
    void setOffsetX(float) -> c
    void setId(int) -> d
    com.badlogic.gdx.maps.MapProperties getProperties() -> e
    void setOffsetY(float) -> f
    com.badlogic.gdx.maps.MapObjects getObjects() -> g
    float getOffsetY() -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> i
    com.badlogic.gdx.maps.tiled.TiledMapTile getCurrentFrame() -> j
    int getCurrentFrameIndex() -> k
    void updateAnimationBaseTime() -> l
com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile -> u.b:
    com.badlogic.gdx.maps.MapObjects objects -> d
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> e
    float offsetY -> g
    float offsetX -> f
    com.badlogic.gdx.maps.MapProperties properties -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode blendMode -> b
    int id -> a
    float getOffsetX() -> a
    int getId() -> b
    void setOffsetX(float) -> c
    void setId(int) -> d
    com.badlogic.gdx.maps.MapProperties getProperties() -> e
    void setOffsetY(float) -> f
    com.badlogic.gdx.maps.MapObjects getObjects() -> g
    float getOffsetY() -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> i
com.badlogic.gdx.math.Affine2 -> v.a:
    float m12 -> i
    float m11 -> h
    float m10 -> g
    float m02 -> f
    float m01 -> e
    float m00 -> d
    com.badlogic.gdx.math.Affine2 preMul(com.badlogic.gdx.math.Affine2) -> a
    com.badlogic.gdx.math.Affine2 setToTrnRotScl(float,float,float,float,float) -> b
    com.badlogic.gdx.math.Affine2 translate(float,float) -> c
com.badlogic.gdx.math.Ellipse -> v.b:
    float height -> g
    float width -> f
    float y -> e
    float x -> d
com.badlogic.gdx.math.Frustum -> v.c:
    com.badlogic.gdx.math.Vector3[] planePoints -> b
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> d
    float[] clipSpacePlanePointsArray -> e
    float[] planePointsArray -> c
    com.badlogic.gdx.math.Plane[] planes -> a
    com.badlogic.gdx.math.Vector3 tmpV -> f
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.Interpolation -> v.d:
    com.badlogic.gdx.math.Interpolation$PowIn pow5In -> v
    com.badlogic.gdx.math.Interpolation$Pow pow2 -> f
    com.badlogic.gdx.math.Interpolation$ExpOut exp10Out -> C
    com.badlogic.gdx.math.Interpolation sineIn -> y
    com.badlogic.gdx.math.Interpolation$SwingOut swingOut -> O
    com.badlogic.gdx.math.Interpolation pow2InInverse -> k
    com.badlogic.gdx.math.Interpolation$Swing swing -> M
    com.badlogic.gdx.math.Interpolation pow3OutInverse -> q
    com.badlogic.gdx.math.Interpolation$PowOut pow4Out -> t
    com.badlogic.gdx.math.Interpolation$Elastic elastic -> J
    com.badlogic.gdx.math.Interpolation$ElasticOut elasticOut -> L
    com.badlogic.gdx.math.Interpolation fade -> e
    com.badlogic.gdx.math.Interpolation smooth2 -> c
    com.badlogic.gdx.math.Interpolation$ExpIn exp10In -> B
    com.badlogic.gdx.math.Interpolation$PowOut fastSlow -> j
    com.badlogic.gdx.math.Interpolation circleIn -> H
    com.badlogic.gdx.math.Interpolation$BounceOut bounceOut -> R
    com.badlogic.gdx.math.Interpolation$Exp exp10 -> A
    com.badlogic.gdx.math.Interpolation$PowIn pow2In -> g
    com.badlogic.gdx.math.Interpolation sineOut -> z
    com.badlogic.gdx.math.Interpolation$Pow pow5 -> u
    com.badlogic.gdx.math.Interpolation linear -> a
    com.badlogic.gdx.math.Interpolation$ElasticIn elasticIn -> K
    com.badlogic.gdx.math.Interpolation$PowIn pow4In -> s
    com.badlogic.gdx.math.Interpolation$Pow pow3 -> m
    com.badlogic.gdx.math.Interpolation sine -> x
    com.badlogic.gdx.math.Interpolation pow2OutInverse -> l
    com.badlogic.gdx.math.Interpolation$PowOut pow5Out -> w
    com.badlogic.gdx.math.Interpolation$Exp exp5 -> D
    com.badlogic.gdx.math.Interpolation pow3InInverse -> p
    com.badlogic.gdx.math.Interpolation$ExpOut exp5Out -> F
    com.badlogic.gdx.math.Interpolation smoother -> d
    com.badlogic.gdx.math.Interpolation$SwingIn swingIn -> N
    com.badlogic.gdx.math.Interpolation$PowOut pow3Out -> o
    com.badlogic.gdx.math.Interpolation smooth -> b
    com.badlogic.gdx.math.Interpolation$ExpIn exp5In -> E
    com.badlogic.gdx.math.Interpolation circleOut -> I
    com.badlogic.gdx.math.Interpolation$PowIn slowFast -> h
    com.badlogic.gdx.math.Interpolation circle -> G
    com.badlogic.gdx.math.Interpolation$PowIn pow3In -> n
    com.badlogic.gdx.math.Interpolation$PowOut pow2Out -> i
    com.badlogic.gdx.math.Interpolation$BounceIn bounceIn -> Q
    com.badlogic.gdx.math.Interpolation$Bounce bounce -> P
    com.badlogic.gdx.math.Interpolation$Pow pow4 -> r
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$1 -> v.d$f:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$10 -> v.d$a:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$11 -> v.d$b:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$12 -> v.d$c:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$13 -> v.d$d:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$14 -> v.d$e:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$2 -> v.d$g:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$3 -> v.d$h:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$4 -> v.d$i:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$5 -> v.d$j:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$6 -> v.d$k:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$7 -> v.d$l:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$8 -> v.d$m:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$9 -> v.d$n:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Bounce -> v.d$o:
    float apply(float) -> a
    float out(float) -> b
com.badlogic.gdx.math.Interpolation$BounceIn -> v.d$p:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceOut -> v.d$q:
    float[] widths -> S
    float[] heights -> T
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Elastic -> v.d$r:
    float bounces -> V
    float scale -> U
    float power -> T
    float value -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticIn -> v.d$s:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticOut -> v.d$t:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Exp -> v.d$u:
    float scale -> V
    float min -> U
    float power -> T
    float value -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpIn -> v.d$v:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpOut -> v.d$w:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Pow -> v.d$x:
    int power -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowIn -> v.d$y:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowOut -> v.d$z:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Swing -> v.d$a0:
    float scale -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingIn -> v.d$b0:
    float scale -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingOut -> v.d$c0:
    float scale -> S
    float apply(float) -> a
com.badlogic.gdx.math.MathUtils -> v.e:
    java.util.Random random -> a
    float clamp(float,float,float) -> a
    int clamp(int,int,int) -> b
    float cos(float) -> c
    float cosDeg(float) -> d
    boolean isEqual(float,float,float) -> e
    boolean isPowerOfTwo(int) -> f
    int nextPowerOfTwo(int) -> g
    int roundPositive(float) -> h
    float sin(float) -> i
    float sinDeg(float) -> j
com.badlogic.gdx.math.MathUtils$Sin -> v.e$a:
    float[] table -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    com.badlogic.gdx.math.Quaternion quat2 -> f
    com.badlogic.gdx.math.Quaternion quat -> e
    com.badlogic.gdx.math.Vector3 tmpUp -> n
    com.badlogic.gdx.math.Matrix4 tmpMat -> k
    com.badlogic.gdx.math.Vector3 right -> l
    com.badlogic.gdx.math.Vector3 tmpForward -> m
    com.badlogic.gdx.math.Vector3 tmpVec -> j
    float[] val -> d
    com.badlogic.gdx.math.Vector3 l_vex -> h
    com.badlogic.gdx.math.Vector3 l_vey -> i
    com.badlogic.gdx.math.Vector3 l_vez -> g
    float det(float[]) -> a
    com.badlogic.gdx.math.Matrix4 idt() -> b
    boolean inv(float[]) -> c
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> d
    void mul(float[],float[]) -> e
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> f
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Affine2) -> g
    com.badlogic.gdx.math.Matrix4 set(float[]) -> h
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> i
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> j
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> k
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> l
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> m
com.badlogic.gdx.math.Plane -> v.f:
    com.badlogic.gdx.math.Vector3 normal -> d
    float d -> e
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
com.badlogic.gdx.math.Polygon -> v.g:
    float scaleY -> e
    float scaleX -> d
    float y -> c
    boolean dirty -> f
    float x -> b
    float[] localVertices -> a
    void setPosition(float,float) -> a
com.badlogic.gdx.math.Polyline -> v.h:
    float scaleY -> e
    float scaleX -> d
    float y -> c
    boolean calculateScaledLength -> f
    float x -> b
    boolean calculateLength -> g
    boolean dirty -> h
    float[] localVertices -> a
    void setPosition(float,float) -> a
com.badlogic.gdx.math.Quaternion -> v.i:
    com.badlogic.gdx.math.Quaternion tmp2 -> i
    com.badlogic.gdx.math.Quaternion tmp1 -> h
    float w -> g
    float z -> f
    float y -> e
    float x -> d
    com.badlogic.gdx.math.Quaternion idt() -> a
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> b
com.badlogic.gdx.math.RandomXS128 -> v.j:
    long seed1 -> e
    long seed0 -> d
    long murmurHash3(long) -> a
    long nextLong(long) -> b
    void setState(long,long) -> c
com.badlogic.gdx.math.Rectangle -> v.k:
    com.badlogic.gdx.math.Rectangle tmp -> h
    float height -> g
    com.badlogic.gdx.math.Rectangle tmp2 -> i
    float width -> f
    float y -> e
    float x -> d
    boolean contains(float,float) -> a
    boolean contains(com.badlogic.gdx.math.Rectangle) -> b
    float getHeight() -> c
    float getWidth() -> d
    boolean overlaps(com.badlogic.gdx.math.Rectangle) -> e
    com.badlogic.gdx.math.Rectangle set(float,float,float,float) -> f
com.badlogic.gdx.math.Vector2 -> v.l:
    float y -> e
    float x -> d
    com.badlogic.gdx.math.Vector2 Y -> g
    com.badlogic.gdx.math.Vector2 Zero -> h
    com.badlogic.gdx.math.Vector2 X -> f
    float dst(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 set(float,float) -> b
    com.badlogic.gdx.math.Vector2 set(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Vector2 sub(com.badlogic.gdx.math.Vector2) -> d
com.badlogic.gdx.math.Vector3 -> v.m:
    float z -> f
    float y -> e
    float x -> d
    com.badlogic.gdx.math.Matrix4 tmpMat -> k
    com.badlogic.gdx.math.Vector3 Zero -> j
    com.badlogic.gdx.math.Vector3 Y -> h
    com.badlogic.gdx.math.Vector3 Z -> i
    com.badlogic.gdx.math.Vector3 X -> g
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> d
    float dot(com.badlogic.gdx.math.Vector3) -> e
    float len2() -> f
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> g
    com.badlogic.gdx.math.Vector3 nor() -> h
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> i
    com.badlogic.gdx.math.Vector3 scl(float) -> j
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> k
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> l
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> m
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> n
com.badlogic.gdx.math.collision.Ray -> w.a:
    com.badlogic.gdx.math.Vector3 origin -> d
    com.badlogic.gdx.math.Vector3 direction -> e
    com.badlogic.gdx.math.Vector3 tmp -> f
com.badlogic.gdx.net.NetJavaImpl -> x.a:
    java.util.concurrent.ThreadPoolExecutor executorService -> a
    com.badlogic.gdx.utils.ObjectMap tasks -> d
    com.badlogic.gdx.utils.ObjectMap listeners -> c
    com.badlogic.gdx.utils.ObjectMap connections -> b
com.badlogic.gdx.net.NetJavaImpl$1 -> x.a$a:
    java.util.concurrent.atomic.AtomicInteger threadID -> a
    com.badlogic.gdx.net.NetJavaImpl this$0 -> b
com.badlogic.gdx.physics.box2d.Body -> com.badlogic.gdx.physics.box2d.Body:
    com.badlogic.gdx.math.Vector2 linVelWorld -> q
    com.badlogic.gdx.math.Vector2 linVelLoc -> r
    java.lang.Object userData -> f
    com.badlogic.gdx.physics.box2d.MassData massData -> l
    com.badlogic.gdx.math.Vector2 localPoint2 -> o
    com.badlogic.gdx.math.Vector2 localVector -> p
    com.badlogic.gdx.physics.box2d.Transform transform -> g
    com.badlogic.gdx.math.Vector2 localPoint -> m
    com.badlogic.gdx.math.Vector2 worldVector -> n
    com.badlogic.gdx.math.Vector2 linearVelocity -> k
    long addr -> a
    com.badlogic.gdx.math.Vector2 worldCenter -> i
    com.badlogic.gdx.math.Vector2 localCenter -> j
    float[] tmp -> b
    com.badlogic.gdx.math.Vector2 position -> h
    com.badlogic.gdx.utils.Array joints -> e
    com.badlogic.gdx.utils.Array fixtures -> d
    com.badlogic.gdx.physics.box2d.World world -> c
    com.badlogic.gdx.physics.box2d.Fixture createFixture(com.badlogic.gdx.physics.box2d.FixtureDef) -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    void reset(long) -> c
    void setLinearVelocity(float,float) -> d
com.badlogic.gdx.physics.box2d.BodyDef -> com.badlogic.gdx.physics.box2d.a:
    boolean awake -> i
    float angularDamping -> g
    boolean fixedRotation -> j
    float linearDamping -> f
    boolean bullet -> k
    float angularVelocity -> e
    boolean active -> l
    float angle -> c
    com.badlogic.gdx.math.Vector2 linearVelocity -> d
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType type -> a
    com.badlogic.gdx.math.Vector2 position -> b
    boolean allowSleep -> h
    float gravityScale -> m
com.badlogic.gdx.physics.box2d.BodyDef$BodyType -> com.badlogic.gdx.physics.box2d.a$a:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] $VALUES -> h
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType DynamicBody -> g
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType KinematicBody -> f
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType StaticBody -> e
    int value -> d
    int getValue() -> a
com.badlogic.gdx.physics.box2d.Contact -> com.badlogic.gdx.physics.box2d.Contact:
    com.badlogic.gdx.physics.box2d.WorldManifold worldManifold -> c
    long addr -> a
    com.badlogic.gdx.physics.box2d.World world -> b
    float[] tmp -> d
com.badlogic.gdx.physics.box2d.ContactFilter -> y.a:
    boolean shouldCollide(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.ContactImpulse -> com.badlogic.gdx.physics.box2d.ContactImpulse:
    long addr -> b
    float[] tangentImpulses -> e
    com.badlogic.gdx.physics.box2d.World world -> a
    float[] tmp -> c
    float[] normalImpulses -> d
com.badlogic.gdx.physics.box2d.ContactListener -> y.b:
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> c
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> d
com.badlogic.gdx.physics.box2d.Filter -> y.c:
    short groupIndex -> c
    short categoryBits -> a
    short maskBits -> b
com.badlogic.gdx.physics.box2d.Fixture -> com.badlogic.gdx.physics.box2d.Fixture:
    com.badlogic.gdx.physics.box2d.Shape shape -> c
    short[] tmp -> g
    java.lang.Object userData -> d
    com.badlogic.gdx.physics.box2d.Filter filter -> e
    long addr -> b
    boolean dirtyFilter -> f
    com.badlogic.gdx.physics.box2d.Body body -> a
    com.badlogic.gdx.physics.box2d.Filter getFilterData() -> a
    void reset(com.badlogic.gdx.physics.box2d.Body,long) -> b
com.badlogic.gdx.physics.box2d.FixtureDef -> y.d:
    com.badlogic.gdx.physics.box2d.Filter filter -> f
    com.badlogic.gdx.physics.box2d.Shape shape -> a
    float density -> d
    boolean isSensor -> e
    float restitution -> c
    float friction -> b
com.badlogic.gdx.physics.box2d.Manifold -> com.badlogic.gdx.physics.box2d.Manifold:
    com.badlogic.gdx.math.Vector2 localNormal -> c
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint[] points -> b
    com.badlogic.gdx.math.Vector2 localPoint -> d
    int[] tmpInt -> e
    long addr -> a
    float[] tmpFloat -> f
com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint -> com.badlogic.gdx.physics.box2d.Manifold$a:
    com.badlogic.gdx.math.Vector2 localPoint -> a
    com.badlogic.gdx.physics.box2d.Manifold this$0 -> e
    float tangentImpulse -> c
    float normalImpulse -> b
    int contactID -> d
com.badlogic.gdx.physics.box2d.MassData -> y.e:
    com.badlogic.gdx.math.Vector2 center -> a
com.badlogic.gdx.physics.box2d.PolygonShape -> com.badlogic.gdx.physics.box2d.PolygonShape:
    float[] verts -> b
    void setAsBox(float,float) -> l
com.badlogic.gdx.physics.box2d.QueryCallback -> y.f:
    boolean reportFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.RayCastCallback -> y.g:
    float reportRayFixture(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
com.badlogic.gdx.physics.box2d.Shape -> com.badlogic.gdx.physics.box2d.Shape:
    long addr -> a
    void dispose() -> b
com.badlogic.gdx.physics.box2d.Transform -> y.h:
    com.badlogic.gdx.math.Vector2 orientation -> c
    com.badlogic.gdx.math.Vector2 position -> b
    float[] vals -> a
com.badlogic.gdx.physics.box2d.World -> com.badlogic.gdx.physics.box2d.World:
    com.badlogic.gdx.utils.Pool freeBodies -> a
    com.badlogic.gdx.math.Vector2 rayPoint -> s
    com.badlogic.gdx.utils.Pool freeFixtures -> b
    com.badlogic.gdx.math.Vector2 rayNormal -> t
    float[] tmpGravity -> i
    com.badlogic.gdx.physics.box2d.Contact contact -> o
    com.badlogic.gdx.physics.box2d.ContactFilter contactFilter -> g
    com.badlogic.gdx.utils.LongMap fixtures -> e
    com.badlogic.gdx.physics.box2d.Manifold manifold -> p
    com.badlogic.gdx.utils.LongMap joints -> f
    long[] contactAddrs -> l
    long addr -> c
    com.badlogic.gdx.math.Vector2 gravity -> j
    com.badlogic.gdx.physics.box2d.RayCastCallback rayCastCallback -> r
    com.badlogic.gdx.utils.LongMap bodies -> d
    com.badlogic.gdx.physics.box2d.ContactListener contactListener -> h
    com.badlogic.gdx.utils.Array contacts -> m
    com.badlogic.gdx.physics.box2d.QueryCallback queryCallback -> k
    com.badlogic.gdx.utils.Array freeContacts -> n
    com.badlogic.gdx.physics.box2d.ContactImpulse impulse -> q
    com.badlogic.gdx.physics.box2d.Body createBody(com.badlogic.gdx.physics.box2d.BodyDef) -> l
com.badlogic.gdx.physics.box2d.World$1 -> com.badlogic.gdx.physics.box2d.World$a:
    com.badlogic.gdx.physics.box2d.World this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.physics.box2d.Body newObject() -> g
com.badlogic.gdx.physics.box2d.World$2 -> com.badlogic.gdx.physics.box2d.World$b:
    com.badlogic.gdx.physics.box2d.World this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.physics.box2d.Fixture newObject() -> g
com.badlogic.gdx.physics.box2d.WorldManifold -> com.badlogic.gdx.physics.box2d.b:
    com.badlogic.gdx.math.Vector2 normal -> a
    com.badlogic.gdx.math.Vector2[] points -> b
    float[] separations -> c
com.badlogic.gdx.scenes.scene2d.Action -> z.a:
    com.badlogic.gdx.utils.Pool pool -> c
    com.badlogic.gdx.scenes.scene2d.Actor target -> b
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    boolean act(float) -> a
    com.badlogic.gdx.utils.Pool getPool() -> b
    void restart() -> c
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void setPool(com.badlogic.gdx.utils.Pool) -> e
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> f
com.badlogic.gdx.scenes.scene2d.Actor -> z.b:
    float width -> l
    java.lang.String name -> f
    float y -> k
    float x -> j
    boolean debug -> i
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> g
    com.badlogic.gdx.scenes.scene2d.Group parent -> b
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> c
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> d
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.utils.Array actions -> e
    float rotation -> r
    boolean visible -> h
    float scaleY -> q
    float scaleX -> p
    float originY -> o
    float originX -> n
    com.badlogic.gdx.graphics.Color color -> s
    float height -> m
    float getOriginY() -> A
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> B
    float getRotation() -> C
    float getScaleX() -> D
    float getScaleY() -> E
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> F
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> G
    float getWidth() -> H
    float getX() -> I
    float getX(int) -> J
    float getY() -> K
    float getY(int) -> L
    boolean hasKeyboardFocus() -> M
    boolean hasParent() -> N
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> O
    boolean isAscendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> P
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> Q
    boolean isTouchable() -> R
    boolean isVisible() -> S
    com.badlogic.gdx.math.Vector2 localToAscendantCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> T
    com.badlogic.gdx.math.Vector2 localToParentCoordinates(com.badlogic.gdx.math.Vector2) -> U
    com.badlogic.gdx.math.Vector2 localToStageCoordinates(com.badlogic.gdx.math.Vector2) -> V
    void moveBy(float,float) -> W
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> X
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> Y
    void positionChanged() -> Z
    boolean remove() -> a0
    boolean removeCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> b0
    boolean removeListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> c0
    void setBounds(float,float,float,float) -> d0
    void setDebug(boolean) -> e0
    void setHeight(float) -> f0
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> g0
    void setPosition(float,float) -> h0
    void setPosition(float,float,int) -> i0
    void act(float) -> j
    void setSize(float,float) -> j0
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> k
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> k0
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> l
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> l0
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> m
    void setVisible(boolean) -> m0
    boolean ascendantsVisible() -> n
    void setWidth(float) -> n0
    void clearActions() -> o
    void setX(float) -> o0
    boolean clipBegin(float,float,float,float) -> p
    void setY(float) -> p0
    void clipEnd() -> q
    boolean setZIndex(int) -> q0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void sizeChanged() -> r0
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> s
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> s0
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> t
    void toFront() -> t0
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> u
    com.badlogic.gdx.graphics.Color getColor() -> v
    boolean getDebug() -> w
    float getHeight() -> x
    java.lang.String getName() -> y
    float getOriginX() -> z
com.badlogic.gdx.scenes.scene2d.Event -> z.c:
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    boolean bubbles -> e
    boolean handled -> f
    boolean stopped -> g
    boolean cancelled -> h
    boolean capture -> d
    boolean getBubbles() -> a
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> b
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> c
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> d
    void handle() -> e
    boolean isCancelled() -> f
    boolean isHandled() -> g
    boolean isStopped() -> h
    void setCapture(boolean) -> i
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> j
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> k
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> l
    void stop() -> m
com.badlogic.gdx.scenes.scene2d.EventListener -> z.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> z.e:
    com.badlogic.gdx.utils.SnapshotArray children -> t
    com.badlogic.gdx.math.Matrix4 oldTransform -> w
    com.badlogic.gdx.math.Rectangle cullingArea -> y
    com.badlogic.gdx.math.Matrix4 computedTransform -> v
    com.badlogic.gdx.math.Affine2 worldTransform -> u
    boolean transform -> x
    com.badlogic.gdx.math.Vector2 tmp -> z
    com.badlogic.gdx.math.Matrix4 computeTransform() -> A0
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> B0
    void drawChildren(com.badlogic.gdx.graphics.g2d.Batch,float) -> C0
    void drawDebugChildren(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> D0
    com.badlogic.gdx.scenes.scene2d.Actor getChild(int) -> E0
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> F0
    boolean isTransform() -> G0
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> H0
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> I0
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> J0
    void resetTransform(com.badlogic.gdx.graphics.g2d.Batch) -> K0
    void resetTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> L0
    void setDebug(boolean,boolean) -> M0
    void setTransform(boolean) -> N0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> O
    void toString(java.lang.StringBuilder,int) -> O0
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> e
    void act(float) -> j
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> s
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> u0
    void applyTransform(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.math.Matrix4) -> v0
    void applyTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer,com.badlogic.gdx.math.Matrix4) -> w0
    void childrenChanged() -> x0
    void clearChildren() -> y0
    void clearChildren(boolean) -> z0
com.badlogic.gdx.scenes.scene2d.InputEvent -> z.f:
    float scrollAmountX -> l
    int pointer -> n
    float stageY -> k
    int button -> o
    float stageX -> j
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> r
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> i
    char character -> q
    int keyCode -> p
    boolean touchFocus -> s
    float scrollAmountY -> m
    void setCharacter(char) -> A
    void setKeyCode(int) -> B
    void setPointer(int) -> C
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> D
    void setScrollAmountX(float) -> E
    void setScrollAmountY(float) -> F
    void setStageX(float) -> G
    void setStageY(float) -> H
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> I
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> J
    int getButton() -> n
    char getCharacter() -> o
    int getKeyCode() -> p
    int getPointer() -> q
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> r
    float getScrollAmountX() -> s
    float getScrollAmountY() -> t
    float getStageX() -> u
    float getStageY() -> v
    boolean getTouchFocus() -> w
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> x
    boolean isTouchFocusCancel() -> y
    void setButton(int) -> z
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> z.f$a:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> n
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> l
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> m
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> f
com.badlogic.gdx.scenes.scene2d.InputListener -> z.g:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> e
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> f
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> g
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> h
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> z.g$a:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> z.h:
    boolean actionsRequestRendering -> o
    int mouseScreenY -> j
    com.badlogic.gdx.graphics.glutils.ShapeRenderer debugShapes -> p
    int mouseScreenX -> i
    com.badlogic.gdx.graphics.g2d.Batch batch -> b
    boolean debug -> v
    boolean debugAll -> q
    boolean debugUnderMouse -> r
    boolean debugParentUnderMouse -> s
    com.badlogic.gdx.scenes.scene2d.Group root -> c
    com.badlogic.gdx.graphics.Color debugColor -> u
    com.badlogic.gdx.math.Vector2 tempCoords -> d
    int[] pointerScreenX -> g
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> e
    int[] pointerScreenY -> h
    com.badlogic.gdx.utils.viewport.Viewport viewport -> a
    boolean[] pointerTouched -> f
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> n
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> m
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> l
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debugTableUnderMouse -> t
    com.badlogic.gdx.scenes.scene2d.Actor mouseOverActor -> k
    boolean keyUp(int) -> A
    boolean keyTyped(char) -> C
    boolean keyDown(int) -> F
    boolean touchCancelled(int,int,int,int) -> J
    boolean scrolled(float,float) -> K
    boolean touchDragged(int,int,int) -> M
    void act(float) -> O
    void actorRemoved(com.badlogic.gdx.scenes.scene2d.Actor) -> P
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> Q
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> R
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> S
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> T
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> U
    void calculateScissors(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> V
    void cancelTouchFocus() -> W
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> X
    void cancelTouchFocusExcept(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor) -> Y
    void disableDebug(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> Z
    void draw() -> a0
    void drawDebug() -> b0
    com.badlogic.gdx.scenes.scene2d.Actor fireEnterAndExit(com.badlogic.gdx.scenes.scene2d.Actor,int,int,int) -> c0
    void fireExit(com.badlogic.gdx.scenes.scene2d.Actor,int,int,int) -> d0
    boolean getActionsRequestRendering() -> e0
    com.badlogic.gdx.utils.Array getActors() -> f0
    com.badlogic.gdx.graphics.Color getDebugColor() -> g0
    float getHeight() -> h0
    com.badlogic.gdx.scenes.scene2d.Actor getKeyboardFocus() -> i0
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> j0
    com.badlogic.gdx.scenes.scene2d.Actor getScrollFocus() -> k0
    boolean touchDown(int,int,int,int) -> l
    float getWidth() -> l0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> m0
    boolean isInsideViewport(int,int) -> n0
    boolean removeCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> o0
    boolean mouseMoved(int,int) -> p
    boolean removeListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> p0
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> q0
    boolean setKeyboardFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> r0
    boolean setScrollFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> s0
    boolean touchUp(int,int,int,int) -> t
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> t0
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> z.h$a:
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    int pointer -> d
    int button -> e
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
com.badlogic.gdx.scenes.scene2d.Touchable -> z.i:
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> f
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> g
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> d
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> e
com.badlogic.gdx.scenes.scene2d.actions.Actions -> a0.a:
    com.badlogic.gdx.scenes.scene2d.Action action(java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float) -> b
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float,float) -> c
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float,float,com.badlogic.gdx.math.Interpolation) -> d
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeIn(float,com.badlogic.gdx.math.Interpolation) -> e
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeOut(float,com.badlogic.gdx.math.Interpolation) -> f
    com.badlogic.gdx.scenes.scene2d.actions.MoveToAction moveTo(float,float) -> g
    com.badlogic.gdx.scenes.scene2d.actions.MoveToAction moveTo(float,float,float) -> h
    com.badlogic.gdx.scenes.scene2d.actions.MoveToAction moveTo(float,float,float,com.badlogic.gdx.math.Interpolation) -> i
    com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction removeActor() -> j
    com.badlogic.gdx.scenes.scene2d.actions.RunnableAction run(java.lang.Runnable) -> k
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> l
com.badlogic.gdx.scenes.scene2d.actions.AlphaAction -> a0.b:
    float end -> k
    float start -> j
    com.badlogic.gdx.graphics.Color color -> l
    void begin() -> g
    void update(float) -> k
    void setAlpha(float) -> l
com.badlogic.gdx.scenes.scene2d.actions.MoveToAction -> a0.c:
    float endX -> l
    int alignment -> n
    float startY -> k
    float startX -> j
    float endY -> m
    void begin() -> g
    void update(float) -> k
    void setPosition(float,float) -> l
com.badlogic.gdx.scenes.scene2d.actions.ParallelAction -> a0.d:
    boolean complete -> e
    com.badlogic.gdx.utils.Array actions -> d
    void restart() -> c
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> g
com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction -> a0.e:
    boolean removed -> d
    boolean act(float) -> a
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.RunnableAction -> a0.f:
    java.lang.Runnable runnable -> d
    boolean ran -> e
    boolean act(float) -> a
    void restart() -> c
    void run() -> g
    void setRunnable(java.lang.Runnable) -> h
com.badlogic.gdx.scenes.scene2d.actions.SequenceAction -> a0.g:
    int index -> f
    boolean act(float) -> a
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.TemporalAction -> a0.h:
    boolean complete -> i
    com.badlogic.gdx.math.Interpolation interpolation -> f
    float time -> e
    float duration -> d
    boolean reverse -> g
    boolean began -> h
    boolean act(float) -> a
    void restart() -> c
    void begin() -> g
    void end() -> h
    void setDuration(float) -> i
    void setInterpolation(com.badlogic.gdx.math.Interpolation) -> j
    void update(float) -> k
com.badlogic.gdx.scenes.scene2d.ui.Button -> b0.a:
    boolean isDisabled -> u0
    boolean isChecked -> t0
    boolean programmaticChangeEvents -> w0
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> v0
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> s0
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getPrefWidth() -> d
    float getPrefHeight() -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> p1
    void initialize() -> q1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    boolean isChecked() -> r1
    boolean isDisabled() -> s1
    boolean isOver() -> t1
    boolean isPressed() -> u1
    void setChecked(boolean) -> v1
    void setChecked(boolean,boolean) -> w1
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> x1
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> b0.a$a:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> b0.a$b:
    float unpressedOffsetX -> l
    float pressedOffsetY -> k
    float pressedOffsetX -> j
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focused -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> g
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedDown -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedFocused -> i
    float checkedOffsetY -> o
    float checkedOffsetX -> n
    float unpressedOffsetY -> m
com.badlogic.gdx.scenes.scene2d.ui.Cell -> b0.b:
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> c
    float computedPadRight -> J
    float computedPadLeft -> H
    int row -> E
    com.badlogic.gdx.Files files -> T
    java.lang.Integer righti -> S
    java.lang.Float fillY -> p
    java.lang.Integer colspan -> t
    java.lang.Boolean uniformY -> v
    float actorY -> y
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> m
    java.lang.Float zerof -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceBottom -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> B
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> k
    java.lang.Integer zeroi -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> e
    java.lang.Integer centeri -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults -> U
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceTop -> g
    boolean endRow -> C
    java.lang.Integer bottomi -> Q
    java.lang.Integer expandX -> r
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> b
    float computedPadBottom -> I
    float computedPadTop -> G
    int cellAboveIndex -> F
    int column -> D
    float actorHeight -> A
    java.lang.Float fillX -> o
    java.lang.Integer expandY -> s
    java.lang.Boolean uniformX -> u
    float actorWidth -> z
    float actorX -> x
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> l
    java.lang.Float onef -> L
    com.badlogic.gdx.scenes.scene2d.Actor actor -> w
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> n
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceLeft -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceRight -> j
    java.lang.Integer onei -> N
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> d
    java.lang.Integer topi -> P
    java.lang.Integer align -> q
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> f
    java.lang.Integer lefti -> R
    com.badlogic.gdx.scenes.scene2d.ui.Cell size(float,float) -> A
    com.badlogic.gdx.scenes.scene2d.ui.Cell size(com.badlogic.gdx.scenes.scene2d.ui.Value,com.badlogic.gdx.scenes.scene2d.ui.Value) -> B
    com.badlogic.gdx.scenes.scene2d.ui.Cell top() -> C
    com.badlogic.gdx.scenes.scene2d.ui.Cell align(int) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell center() -> b
    void clear() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell colspan(int) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell expand() -> f
    com.badlogic.gdx.scenes.scene2d.ui.Cell expandX() -> g
    com.badlogic.gdx.scenes.scene2d.ui.Cell expandY() -> h
    com.badlogic.gdx.scenes.scene2d.ui.Cell fill() -> i
    com.badlogic.gdx.scenes.scene2d.ui.Cell growX() -> j
    com.badlogic.gdx.scenes.scene2d.ui.Cell growY() -> k
    com.badlogic.gdx.scenes.scene2d.ui.Cell height(float) -> l
    com.badlogic.gdx.scenes.scene2d.ui.Cell height(com.badlogic.gdx.scenes.scene2d.ui.Value) -> m
    com.badlogic.gdx.scenes.scene2d.ui.Cell left() -> n
    com.badlogic.gdx.scenes.scene2d.ui.Cell maxHeight(float) -> o
    void merge(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> p
    com.badlogic.gdx.scenes.scene2d.ui.Cell pad(float) -> q
    com.badlogic.gdx.scenes.scene2d.ui.Cell pad(com.badlogic.gdx.scenes.scene2d.ui.Value) -> r
    com.badlogic.gdx.scenes.scene2d.ui.Cell padBottom(float) -> s
    com.badlogic.gdx.scenes.scene2d.ui.Cell padLeft(float) -> t
    com.badlogic.gdx.scenes.scene2d.ui.Cell padRight(float) -> u
    com.badlogic.gdx.scenes.scene2d.ui.Cell padTop(float) -> v
    com.badlogic.gdx.scenes.scene2d.ui.Cell right() -> w
    void row() -> x
    void set(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> y
    void setTable(com.badlogic.gdx.scenes.scene2d.ui.Table) -> z
com.badlogic.gdx.scenes.scene2d.ui.CheckBox -> b0.c:
    com.badlogic.gdx.scenes.scene2d.ui.Image image -> z0
    com.badlogic.gdx.scenes.scene2d.ui.Cell imageCell -> A0
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle style -> B0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getImageDrawable() -> B1
    com.badlogic.gdx.scenes.scene2d.ui.Image newImage() -> C1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> x1
com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle -> b0.c$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOn -> z
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOff -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOnOver -> B
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOver -> C
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOnDisabled -> D
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOffDisabled -> E
com.badlogic.gdx.scenes.scene2d.ui.Image -> b0.d:
    com.badlogic.gdx.utils.Scaling scaling -> w
    float imageY -> z
    float imageX -> y
    int align -> x
    float imageHeight -> B
    float imageWidth -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable drawable -> C
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getPrefWidth() -> d
    float getPrefHeight() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void layout() -> v0
    void setDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> w0
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle -> b0.e:
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle -> b0.f:
com.badlogic.gdx.scenes.scene2d.ui.Label -> b0.g:
    float fontScaleY -> J
    float fontScaleX -> I
    float lastPrefHeight -> G
    boolean fontScaleChanged -> K
    java.lang.String ellipsis -> L
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> w
    int labelAlign -> D
    int lineAlign -> E
    int intValue -> B
    float prefHeight -> z
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> x
    float prefWidth -> y
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> C
    com.badlogic.gdx.utils.StringBuilder text -> A
    com.badlogic.gdx.graphics.Color tempColor -> M
    boolean wrap -> F
    com.badlogic.gdx.graphics.g2d.GlyphLayout prefSizeLayout -> N
    boolean prefSizeInvalid -> H
    void setAlignment(int) -> A0
    void setAlignment(int,int) -> B0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> C0
    float getPrefWidth() -> d
    float getPrefHeight() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void invalidate() -> u0
    void layout() -> v0
    void computePrefSize(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> w0
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle getStyle() -> x0
    com.badlogic.gdx.utils.StringBuilder getText() -> y0
    void scaleAndComputePrefSize() -> z0
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> b0.g$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
com.badlogic.gdx.scenes.scene2d.ui.List -> b0.h:
    com.badlogic.gdx.math.Rectangle cullingArea -> z
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle style -> w
    int overIndex -> F
    float itemHeight -> C
    com.badlogic.gdx.scenes.scene2d.InputListener keyListener -> G
    float prefHeight -> B
    int alignment -> D
    com.badlogic.gdx.scenes.scene2d.utils.ArraySelection selection -> y
    float prefWidth -> A
    int pressedIndex -> E
    boolean typeToSelect -> H
    com.badlogic.gdx.utils.Array items -> x
    int getItemIndexAt(float) -> A0
    com.badlogic.gdx.scenes.scene2d.InputListener getKeyListener() -> B0
    java.lang.Object getSelected() -> C0
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle getStyle() -> D0
    void setItems(com.badlogic.gdx.utils.Array) -> E0
    void setSelectedIndex(int) -> F0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle) -> G0
    void setTypeToSelect(boolean) -> H0
    java.lang.String toString(java.lang.Object) -> I0
    float getPrefWidth() -> d
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> e
    float getPrefHeight() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void layout() -> v0
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float) -> w0
    com.badlogic.gdx.graphics.g2d.GlyphLayout drawItem(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,int,java.lang.Object,float,float,float) -> x0
    void drawSelection(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.scenes.scene2d.utils.Drawable,float,float,float,float) -> y0
    float getItemHeight() -> z0
com.badlogic.gdx.scenes.scene2d.ui.List$1 -> b0.h$a:
    com.badlogic.gdx.scenes.scene2d.ui.List this$0 -> d
    long typeTimeout -> b
    java.lang.String prefix -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> e
com.badlogic.gdx.scenes.scene2d.ui.List$2 -> b0.h$b:
    com.badlogic.gdx.scenes.scene2d.ui.List this$0 -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> g
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle -> b0.h$c:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> e
    com.badlogic.gdx.graphics.Color fontColorUnselected -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> f
    com.badlogic.gdx.graphics.Color fontColorSelected -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> g
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle -> b0.i:
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane -> b0.j:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> E
    float fadeDelay -> e0
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle style -> D
    boolean scrollY -> N
    float fadeAlphaSeconds -> d0
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener flickScrollListener -> L
    boolean hScrollOnBottom -> P
    float fadeDelaySeconds -> f0
    boolean cancelTouchFocus -> g0
    float flingTime -> i0
    boolean smoothScrolling -> a0
    boolean scrollBarTouch -> b0
    float velocityX -> k0
    float flingTimer -> j0
    float velocityY -> l0
    float overscrollDistance -> o0
    boolean touchScrollV -> X
    float overscrollSpeedMax -> q0
    float overscrollSpeedMin -> p0
    com.badlogic.gdx.math.Rectangle hScrollBounds -> G
    com.badlogic.gdx.math.Rectangle vScrollBounds -> I
    boolean fadeScrollBars -> Z
    float maxY -> V
    com.badlogic.gdx.math.Rectangle actorCullingArea -> K
    float visualAmountY -> T
    float amountY -> R
    com.badlogic.gdx.math.Vector2 lastPoint -> Y
    float fadeAlpha -> c0
    boolean scrollX -> M
    boolean vScrollOnRight -> O
    boolean touchScrollH -> W
    boolean variableSizeKnobs -> x0
    com.badlogic.gdx.math.Rectangle actorArea -> F
    boolean disableY -> u0
    boolean disableX -> t0
    com.badlogic.gdx.math.Rectangle hKnobBounds -> H
    boolean scrollbarsOnTop -> w0
    boolean clamp -> v0
    com.badlogic.gdx.math.Rectangle vKnobBounds -> J
    boolean forceScrollY -> s0
    float maxX -> U
    boolean forceScrollX -> r0
    boolean overscrollX -> m0
    float visualAmountX -> S
    float amountX -> Q
    boolean overscrollY -> n0
    int draggingPointer -> y0
    boolean flickScroll -> h0
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> I0
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> J0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> O
    void layout() -> Q0
    void addCaptureListener() -> S0
    void addScrollListener() -> T0
    void cancel() -> U0
    void cancelTouchFocus() -> V0
    void clamp() -> W0
    void drawScrollBars(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> X0
    void fling(float,float,float) -> Y0
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener getFlickScrollListener() -> Z0
    float getMinHeight() -> a
    float getMouseWheelX() -> a1
    float getMinWidth() -> b
    float getMouseWheelY() -> b1
    float getScrollPercentX() -> c1
    float getPrefWidth() -> d
    float getScrollPercentY() -> d1
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle getStyle() -> e1
    float getPrefHeight() -> f
    float getVisualScrollPercentX() -> f1
    float getVisualScrollPercentY() -> g1
    void scrollTo(float,float,float,float,boolean,boolean) -> h1
    void scrollX(float) -> i1
    void act(float) -> j
    void scrollY(float) -> j1
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> k1
    void setFadeScrollBars(boolean) -> l1
    void setOverscroll(boolean,boolean) -> m1
    void setScrollPercentX(float) -> n1
    void setScrollPercentY(float) -> o1
    void setScrollX(float) -> p1
    void setScrollY(float) -> q1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void setScrollbarsVisible(boolean) -> r1
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> s
    void setScrollingDisabled(boolean,boolean) -> s1
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle) -> t1
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> u0
    void updateActorPosition() -> u1
    void updateVisualScroll() -> v1
    void visualScrollX(float) -> w1
    void visualScrollY(float) -> x1
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$1 -> b0.j$a:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> c
    float handlePosition -> b
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> g
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$2 -> b0.j$b:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> g
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> e
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$3 -> b0.j$c:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> b
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> h
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle -> b0.j$d:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable corner -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScroll -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScrollKnob -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScroll -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScrollKnob -> f
com.badlogic.gdx.scenes.scene2d.ui.SelectBox -> b0.k:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle style -> w
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> B
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane scrollPane -> y
    float prefWidth -> z
    boolean selectedPrefWidth -> E
    int alignment -> D
    float prefHeight -> A
    com.badlogic.gdx.math.Vector2 temp -> G
    com.badlogic.gdx.utils.Array items -> x
    boolean disabled -> C
    com.badlogic.gdx.scenes.scene2d.utils.ArraySelection selection -> F
    int getSelectedIndex() -> A0
    void hideScrollPane() -> B0
    boolean isDisabled() -> C0
    boolean isOver() -> D0
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane newScrollPane() -> E0
    void onHide(com.badlogic.gdx.scenes.scene2d.Actor) -> F0
    void onShow(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> G0
    void setAlignment(int) -> H0
    void setItems(java.lang.Object[]) -> I0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle) -> J0
    void showScrollPane() -> K0
    java.lang.String toString(java.lang.Object) -> L0
    float getPrefWidth() -> d
    float getPrefHeight() -> f
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void layout() -> v0
    com.badlogic.gdx.graphics.g2d.GlyphLayout drawItem(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.Object,float,float,float) -> w0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> x0
    com.badlogic.gdx.graphics.Color getFontColor() -> y0
    java.lang.Object getSelected() -> z0
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$1 -> b0.k$a:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox this$0 -> p
    boolean fireChangeEvent() -> e
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$2 -> b0.k$b:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox this$0 -> p
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane -> b0.k$c:
    int maxListCount -> A0
    com.badlogic.gdx.scenes.scene2d.ui.List list -> C0
    com.badlogic.gdx.math.Vector2 stagePosition -> B0
    com.badlogic.gdx.scenes.scene2d.InputListener hideListener -> D0
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox selectBox -> z0
    com.badlogic.gdx.scenes.scene2d.Actor previousScrollFocus -> E0
    void show(com.badlogic.gdx.scenes.scene2d.Stage) -> A1
    void act(float) -> j
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void hide() -> y1
    com.badlogic.gdx.scenes.scene2d.ui.List newList() -> z1
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane$1 -> b0.k$c$a:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> p
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane this$0 -> q
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> g
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane$2 -> b0.k$c$b:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane$3 -> b0.k$c$c:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane$4 -> b0.k$c$d:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxScrollPane this$0 -> I
    java.lang.String toString(java.lang.Object) -> I0
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle -> b0.k$d:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOver -> h
    com.badlogic.gdx.graphics.Color disabledFontColor -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOpen -> i
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundDisabled -> j
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle scrollStyle -> f
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle listStyle -> g
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
    com.badlogic.gdx.graphics.Color overFontColor -> c
    com.badlogic.gdx.graphics.Color fontColor -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin -> b0.l:
    java.lang.Class[] defaultTagClasses -> d
    com.badlogic.gdx.utils.ObjectMap resources -> a
    float scale -> b
    com.badlogic.gdx.utils.ObjectMap jsonClassTags -> c
    java.lang.Object get(java.lang.Class) -> A
    java.lang.Object get(java.lang.String,java.lang.Class) -> C
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> F
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> J
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> K
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> M
    com.badlogic.gdx.utils.Array getRegions(java.lang.String) -> O
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> P
    void load(com.badlogic.gdx.files.FileHandle) -> Q
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> R
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> S
    java.lang.Object optional(java.lang.String,java.lang.Class) -> T
    void scale(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> U
    void add(java.lang.String,java.lang.Object) -> l
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> p
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> t
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> b0.l$a:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> q
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> g
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> i
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> b0.l$b:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> c
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> b0.l$c:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> b0.l$d:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> b0.l$e:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> b0.l$f:
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle -> b0.m:
com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle -> b0.n:
com.badlogic.gdx.scenes.scene2d.ui.Table -> b0.o:
    float[] rowMinHeight -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundLeft -> p0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundTop -> o0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundRight -> r0
    boolean clip -> f0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundBottom -> q0
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> Y
    int rows -> E
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> g0
    float[] expandHeight -> W
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> a0
    float[] rowHeight -> U
    float tablePrefWidth -> R
    com.badlogic.gdx.utils.Array columnDefaults -> I
    float tableMinWidth -> P
    com.badlogic.gdx.utils.Array cells -> G
    float[] rowPrefHeight -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell rowDefaults -> J
    float[] columnPrefWidth -> N
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debug -> c0
    int align -> b0
    float[] columnMinWidth -> L
    com.badlogic.gdx.utils.Pool cellPool -> l0
    boolean sizeInvalid -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> X
    float[] columnWeightedWidth -> m0
    int columns -> D
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> Z
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e0
    com.badlogic.gdx.graphics.Color debugTableColor -> i0
    com.badlogic.gdx.graphics.Color debugCellColor -> j0
    com.badlogic.gdx.graphics.Color debugActorColor -> k0
    float[] rowWeightedHeight -> n0
    com.badlogic.gdx.scenes.scene2d.ui.Cell cellDefaults -> H
    com.badlogic.gdx.utils.Array debugRects -> d0
    boolean implicitEndRow -> F
    float tablePrefHeight -> S
    float[] expandWidth -> V
    float tableMinHeight -> Q
    float[] columnWidth -> T
    boolean round -> h0
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> B0
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> I0
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> J0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> O
    void invalidate() -> P0
    void layout() -> Q0
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> S0
    void addDebugRect(float,float,float,float,com.badlogic.gdx.graphics.Color) -> T0
    void addDebugRects(float,float,float,float) -> U0
    void clearDebugRects() -> V0
    void computeSize() -> W0
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.badlogic.gdx.scenes.scene2d.ui.Table$Debug) -> X0
    com.badlogic.gdx.scenes.scene2d.ui.Table debugAll() -> Y0
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> Z0
    float getMinHeight() -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> a1
    float getMinWidth() -> b
    void drawDebugRects(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b1
    void endRow() -> c1
    float getPrefWidth() -> d
    float[] ensureSize(float[],int) -> d1
    void setDebug(boolean) -> e0
    com.badlogic.gdx.scenes.scene2d.ui.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> e1
    float getPrefHeight() -> f
    float getPadBottom() -> f1
    float getPadLeft() -> g1
    float getPadRight() -> h1
    float getPadTop() -> i1
    com.badlogic.gdx.scenes.scene2d.ui.Cell obtainCell() -> j1
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(float) -> k1
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(com.badlogic.gdx.scenes.scene2d.ui.Value) -> l1
    com.badlogic.gdx.scenes.scene2d.ui.Cell row() -> m1
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> n1
    void setSkin(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> o1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> s
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> t
    void clearChildren(boolean) -> z0
com.badlogic.gdx.scenes.scene2d.ui.Table$1 -> b0.o$a:
    java.lang.Object newObject() -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell newObject() -> g
com.badlogic.gdx.scenes.scene2d.ui.Table$2 -> b0.o$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$3 -> b0.o$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$4 -> b0.o$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$5 -> b0.o$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$Debug -> b0.o$f:
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] $VALUES -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug actor -> h
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug all -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug none -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug cell -> g
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug table -> f
com.badlogic.gdx.scenes.scene2d.ui.Table$DebugRect -> b0.o$g:
    com.badlogic.gdx.graphics.Color color -> j
    com.badlogic.gdx.utils.Pool pool -> k
com.badlogic.gdx.scenes.scene2d.ui.TextButton -> b0.p:
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> x0
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle style -> y0
    com.badlogic.gdx.scenes.scene2d.ui.Label newLabel(java.lang.String,com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> A1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> x1
    com.badlogic.gdx.graphics.Color getFontColor() -> y1
    com.badlogic.gdx.scenes.scene2d.ui.Label getLabel() -> z1
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle -> b0.p$a:
    com.badlogic.gdx.graphics.Color disabledFontColor -> u
    com.badlogic.gdx.graphics.Color focusedFontColor -> t
    com.badlogic.gdx.graphics.Color checkedDownFontColor -> w
    com.badlogic.gdx.graphics.Color checkedFontColor -> v
    com.badlogic.gdx.graphics.Color checkedFocusedFontColor -> y
    com.badlogic.gdx.graphics.Color checkedOverFontColor -> x
    com.badlogic.gdx.graphics.Color fontColor -> q
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> p
    com.badlogic.gdx.graphics.Color overFontColor -> s
    com.badlogic.gdx.graphics.Color downFontColor -> r
com.badlogic.gdx.scenes.scene2d.ui.TextField -> b0.q:
    boolean focused -> d0
    boolean disabled -> N
    int textHAlign -> O
    boolean cursorOn -> e0
    float blinkTime -> f0
    boolean focusTraversal -> L
    float keyRepeatInitialTime -> m0
    com.badlogic.gdx.utils.Timer$Task blinkTask -> g0
    float keyRepeatTime -> n0
    java.lang.StringBuilder passwordBuffer -> U
    boolean passwordMode -> T
    com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard keyboard -> K
    float renderOffset -> Z
    com.badlogic.gdx.math.Vector2 tmp3 -> l0
    float textHeight -> X
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener listener -> I
    int selectionStart -> y
    boolean writeEnters -> A
    float selectionX -> P
    boolean onlyFontChars -> M
    int maxLength -> c0
    int visibleTextEnd -> b0
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter filter -> J
    int visibleTextStart -> a0
    com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask keyRepeatTask -> h0
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> B
    java.lang.CharSequence displayText -> F
    com.badlogic.gdx.utils.FloatArray glyphPositions -> C
    com.badlogic.gdx.math.Vector2 tmp2 -> k0
    java.lang.String undoText -> R
    com.badlogic.gdx.math.Vector2 tmp1 -> j0
    char passwordCharacter -> V
    java.lang.String text -> w
    float textOffset -> Y
    boolean hasSelection -> z
    float fontOffset -> W
    int cursor -> x
    com.badlogic.gdx.utils.Clipboard clipboard -> G
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle style -> D
    com.badlogic.gdx.scenes.scene2d.InputListener inputListener -> H
    float selectionWidth -> Q
    long lastChangeTime -> S
    boolean programmaticChangeEvents -> i0
    java.lang.String messageText -> E
    void copy() -> A0
    com.badlogic.gdx.scenes.scene2d.InputListener createInputListener() -> B0
    void cut(boolean) -> C0
    int delete(boolean) -> D0
    void drawCursor(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> E0
    void drawMessageText(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float,float) -> F0
    void drawSelection(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> G0
    void drawText(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> H0
    com.badlogic.gdx.scenes.scene2d.ui.TextField findNextTextField(com.badlogic.gdx.utils.Array,com.badlogic.gdx.scenes.scene2d.ui.TextField,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,boolean) -> I0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> J0
    java.lang.String getText() -> K0
    float getTextY(com.badlogic.gdx.graphics.g2d.BitmapFont,com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> L0
    void initialize() -> M0
    java.lang.String insert(int,java.lang.CharSequence,java.lang.String) -> N0
    boolean isDisabled() -> O0
    boolean isWordCharacter(char) -> P0
    int letterUnderCursor(float) -> Q0
    void moveCursor(boolean,boolean) -> R0
    void next(boolean) -> S0
    void paste(java.lang.String,boolean) -> T0
    void selectAll() -> U0
    void setAlignment(int) -> V0
    void setDisabled(boolean) -> W0
    void setMaxLength(int) -> X0
    void setSelection(int,int) -> Y0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle) -> Z0
    void setText(java.lang.String) -> a1
    void setTextFieldFilter(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter) -> b1
    void updateDisplayText() -> c1
    float getPrefWidth() -> d
    boolean withinMaxLength(int) -> d1
    int[] wordUnderCursor(float) -> e1
    float getPrefHeight() -> f
    int[] wordUnderCursor(int) -> f1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void calculateOffsets() -> w0
    boolean changeText(java.lang.String,java.lang.String) -> x0
    void clearSelection() -> y0
    boolean continueCursor(int,int) -> z0
com.badlogic.gdx.scenes.scene2d.ui.TextField$1 -> b0.q$a:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> i
com.badlogic.gdx.scenes.scene2d.ui.TextField$DefaultOnscreenKeyboard -> b0.q$b:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask -> b0.q$c:
    int keycode -> i
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> j
com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard -> b0.q$d:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldClickListener -> b0.q$e:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> p
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> e
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> f
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
    boolean checkFocusTraversal(char) -> u
    void goEnd(boolean) -> v
    void goHome(boolean) -> w
    void scheduleKeyRepeatTask(int) -> x
    void setCursorPosition(float,float) -> y
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter -> b0.q$f:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter$DigitsOnlyFilter -> b0.q$f$a:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener -> b0.q$g:
    void keyTyped(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle -> b0.q$h:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable cursor -> h
    com.badlogic.gdx.graphics.Color disabledFontColor -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> i
    com.badlogic.gdx.graphics.Color messageFontColor -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont messageFont -> j
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
    com.badlogic.gdx.graphics.Color focusedFontColor -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focusedBackground -> f
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledBackground -> g
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle -> b0.r:
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle -> b0.s:
com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle -> b0.t:
com.badlogic.gdx.scenes.scene2d.ui.Value -> b0.u:
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed zero -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> g
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> f
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$1 -> b0.u$a:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$2 -> b0.u$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$3 -> b0.u$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$4 -> b0.u$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$5 -> b0.u$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$6 -> b0.u$f:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed -> b0.u$g:
    float value -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed[] cache -> i
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed valueOf(float) -> b
com.badlogic.gdx.scenes.scene2d.ui.Widget -> b0.v:
    boolean fillParent -> u
    boolean layoutEnabled -> v
    boolean needsLayout -> t
    float getMinHeight() -> a
    float getMinWidth() -> b
    void invalidateHierarchy() -> c
    float getPrefWidth() -> d
    float getPrefHeight() -> f
    float getMaxHeight() -> g
    float getMaxWidth() -> h
    void validate() -> i
    void sizeChanged() -> r0
    void invalidate() -> u0
    void layout() -> v0
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> b0.w:
    boolean needsLayout -> A
    boolean fillParent -> B
    boolean layoutEnabled -> C
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> O
    void invalidate() -> P0
    void layout() -> Q0
    void setFillParent(boolean) -> R0
    void invalidateHierarchy() -> c
    float getMaxHeight() -> g
    float getMaxWidth() -> h
    void validate() -> i
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> r
    void sizeChanged() -> r0
    void childrenChanged() -> x0
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle -> b0.x:
    com.badlogic.gdx.graphics.Color titleFontColor -> a
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener -> c0.a:
    com.badlogic.gdx.scenes.scene2d.Actor touchDownTarget -> d
    com.badlogic.gdx.scenes.scene2d.Actor actor -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent event -> b
    com.badlogic.gdx.input.GestureDetector detector -> a
    com.badlogic.gdx.math.Vector2 tmpCoords -> e
    com.badlogic.gdx.math.Vector2 tmpCoords2 -> f
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
    com.badlogic.gdx.input.GestureDetector getGestureDetector() -> c
    boolean longPress(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> d
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> e
    void panStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> f
    void pinch(com.badlogic.gdx.scenes.scene2d.InputEvent,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> g
    void tap(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> h
    void touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> j
    void zoom(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> k
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$1 -> c0.a$a:
    com.badlogic.gdx.math.Vector2 pointer1 -> c
    com.badlogic.gdx.math.Vector2 pointer2 -> d
    com.badlogic.gdx.math.Vector2 initialPointer1 -> a
    com.badlogic.gdx.math.Vector2 initialPointer2 -> b
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener this$0 -> e
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    boolean fling(float,float,int) -> c
    boolean longPress(float,float) -> d
    boolean pan(float,float,float,float) -> f
    boolean panStop(float,float,int,int) -> g
    boolean zoom(float,float) -> h
    boolean tap(float,float,int,int) -> i
    void stageToLocalAmount(com.badlogic.gdx.math.Vector2) -> j
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$2 -> c0.a$b:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.ArraySelection -> c0.b:
    com.badlogic.gdx.utils.Array array -> m
    boolean rangeSelect -> n
    java.lang.Object rangeStart -> o
    void changed() -> b
    void choose(java.lang.Object) -> c
    void validate() -> n
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> c0.c:
    float minHeight -> g
    float minWidth -> f
    float bottomHeight -> e
    float topHeight -> d
    float rightWidth -> c
    java.lang.String name -> a
    float leftWidth -> b
    float getMinHeight() -> a
    float getMinWidth() -> b
    void setMinHeight(float) -> c
    void setLeftWidth(float) -> e
    float getTopHeight() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> g
    void setBottomHeight(float) -> h
    void setTopHeight(float) -> i
    float getLeftWidth() -> j
    void setMinWidth(float) -> k
    float getRightWidth() -> l
    float getBottomHeight() -> m
    void setRightWidth(float) -> n
    java.lang.String getName() -> o
    void setName(java.lang.String) -> p
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener -> c0.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> c0.d$a:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> c0.e:
    long tapCountInterval -> l
    long visualPressedTime -> k
    int tapCount -> m
    boolean over -> i
    boolean cancelled -> j
    float touchDownY -> d
    int pressedButton -> f
    float touchDownX -> c
    int button -> g
    float tapSquareSize -> b
    int pressedPointer -> e
    boolean pressed -> h
    long lastTapTime -> n
    float visualPressedDuration -> o
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
    int getTapCount() -> m
    boolean inTapSquare(float,float) -> n
    void invalidateTapSquare() -> o
    boolean isOver() -> p
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> q
    boolean isPressed() -> r
    boolean isVisualPressed() -> s
    void setVisualPressed(boolean) -> t
com.badlogic.gdx.scenes.scene2d.utils.Cullable -> c0.f:
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> e
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> c0.g:
    float getMinHeight() -> a
    float getMinWidth() -> b
    void setMinHeight(float) -> c
    void setLeftWidth(float) -> e
    float getTopHeight() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> g
    void setBottomHeight(float) -> h
    void setTopHeight(float) -> i
    float getLeftWidth() -> j
    void setMinWidth(float) -> k
    float getRightWidth() -> l
    float getBottomHeight() -> m
    void setRightWidth(float) -> n
com.badlogic.gdx.scenes.scene2d.utils.FocusListener -> c0.h:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
    void scrollFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> c
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$1 -> c0.h$a:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$utils$FocusListener$FocusEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent -> c0.h$b:
    boolean focused -> i
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type type -> j
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> k
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type getType() -> n
    boolean isFocused() -> o
    void setFocused(boolean) -> p
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> q
    void setType(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type) -> r
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type -> c0.h$b$a:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] $VALUES -> f
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type keyboard -> d
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type scroll -> e
com.badlogic.gdx.scenes.scene2d.utils.Layout -> c0.i:
    float getMinHeight() -> a
    float getMinWidth() -> b
    void invalidateHierarchy() -> c
    float getPrefWidth() -> d
    float getPrefHeight() -> f
    float getMaxHeight() -> g
    float getMaxWidth() -> h
    void validate() -> i
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> c0.j:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> g
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> q
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> r
    com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable tint(com.badlogic.gdx.graphics.Color) -> s
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> c0.k:
    com.badlogic.gdx.math.Vector3 tmp -> b
    com.badlogic.gdx.utils.Array scissors -> a
    com.badlogic.gdx.math.Rectangle viewport -> c
    void calculateScissors(com.badlogic.gdx.graphics.Camera,float,float,float,float,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> b
    com.badlogic.gdx.math.Rectangle popScissors() -> c
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> d
com.badlogic.gdx.scenes.scene2d.utils.Selection -> c0.l:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> d
    boolean multiple -> i
    boolean required -> j
    boolean programmaticChangeEvents -> k
    com.badlogic.gdx.utils.OrderedSet selected -> e
    com.badlogic.gdx.utils.OrderedSet old -> f
    boolean isDisabled -> g
    boolean toggle -> h
    java.lang.Object lastSelected -> l
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void changed() -> b
    void choose(java.lang.Object) -> c
    void cleanup() -> d
    boolean fireChangeEvent() -> e
    boolean getMultiple() -> f
    boolean isDisabled() -> g
    com.badlogic.gdx.utils.OrderedSet items() -> h
    void revert() -> i
    void set(java.lang.Object) -> j
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> k
    void setRequired(boolean) -> l
    void snapshot() -> m
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> c0.m:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> g
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> q
    com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable tint(com.badlogic.gdx.graphics.Color) -> r
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> c0.n:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> g
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> q
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> r
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> s
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> c0.o:
    float scale -> j
    com.badlogic.gdx.graphics.Color color -> i
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> g
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> s
    com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable tint(com.badlogic.gdx.graphics.Color) -> t
com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable -> c0.p:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
com.badlogic.gdx.scenes.scene2d.utils.UIUtils -> c0.q:
    boolean isIos -> e
    boolean isAndroid -> a
    boolean isMac -> b
    boolean isWindows -> c
    boolean isLinux -> d
    boolean ctrl() -> a
    boolean shift() -> b
com.badlogic.gdx.utils.Array -> d0.a:
    java.lang.Object[] items -> d
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> g
    boolean ordered -> f
    int size -> e
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> b
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> c
    void addAll(java.lang.Object[]) -> d
    void addAll(java.lang.Object[],int,int) -> e
    boolean contains(java.lang.Object,boolean) -> f
    java.lang.Object[] ensureCapacity(int) -> g
    int indexOf(java.lang.Object,boolean) -> h
    void insert(int,java.lang.Object) -> i
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> j
    boolean notEmpty() -> k
    java.lang.Object removeIndex(int) -> l
    void removeRange(int,int) -> m
    boolean removeValue(java.lang.Object,boolean) -> n
    java.lang.Object[] resize(int) -> o
    void sort() -> p
    java.lang.Object[] toArray(java.lang.Class) -> q
    java.lang.String toString(java.lang.String) -> r
    void truncate(int) -> s
    com.badlogic.gdx.utils.Array with(java.lang.Object[]) -> t
com.badlogic.gdx.utils.Array$ArrayIterable -> d0.a$a:
    boolean allowRemove -> e
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> f
    com.badlogic.gdx.utils.Array array -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> g
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.Array$ArrayIterator -> d0.a$b:
    boolean allowRemove -> e
    int index -> f
    com.badlogic.gdx.utils.Array array -> d
    boolean valid -> g
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.ArrayMap -> d0.b:
    java.lang.Object[] keys -> d
    java.lang.Object[] values -> e
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> h
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> i
    int size -> f
    boolean ordered -> g
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> a
    java.lang.Object get(java.lang.Object) -> b
    java.lang.Object get(java.lang.Object,java.lang.Object) -> c
    int indexOfKey(java.lang.Object) -> d
    int put(java.lang.Object,java.lang.Object) -> e
    void removeIndex(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.ArrayMap$Entries -> d0.b$a:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> e
    com.badlogic.gdx.utils.ArrayMap map -> d
    int index -> f
    boolean valid -> g
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
com.badlogic.gdx.utils.Base64Coder -> d0.c:
    com.badlogic.gdx.utils.Base64Coder$CharMap regularMap -> a
    com.badlogic.gdx.utils.Base64Coder$CharMap urlsafeMap -> b
    byte[] decode(java.lang.String) -> a
    byte[] decode(char[]) -> b
    byte[] decode(char[],int,int,byte[]) -> c
com.badlogic.gdx.utils.Base64Coder$CharMap -> d0.c$a:
    char[] encodingMap -> a
    byte[] decodingMap -> b
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    int bytesToElements(java.nio.Buffer,int) -> a
    void copy(java.nio.Buffer,java.nio.Buffer,int) -> b
    void copy(byte[],int,java.nio.Buffer,int) -> c
    void copy(float[],java.nio.Buffer,int,int) -> d
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> e
    int elementsToBytes(java.nio.Buffer,int) -> f
    boolean isUnsafeByteBuffer(java.nio.ByteBuffer) -> g
    java.nio.ByteBuffer newByteBuffer(int) -> h
    java.nio.FloatBuffer newFloatBuffer(int) -> i
    java.nio.IntBuffer newIntBuffer(int) -> j
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> k
    int positionInBytes(java.nio.Buffer) -> l
com.badlogic.gdx.utils.Clipboard -> d0.d:
    void setContents(java.lang.String) -> a
    java.lang.String getContents() -> b
com.badlogic.gdx.utils.Collections -> d0.e:
    boolean allocateIterators -> a
com.badlogic.gdx.utils.ComparableTimSort -> d0.f:
    int[] runBase -> f
    int[] runLen -> g
    java.lang.Object[] tmp -> c
    int tmpCount -> d
    int stackSize -> e
    int minGallop -> b
    void binarySort(java.lang.Object[],int,int,int) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int) -> b
    void doSort(java.lang.Object[],int,int) -> c
    java.lang.Object[] ensureCapacity(int) -> d
    int gallopLeft(java.lang.Comparable,java.lang.Object[],int,int,int) -> e
    int gallopRight(java.lang.Comparable,java.lang.Object[],int,int,int) -> f
    void mergeAt(int) -> g
    void mergeCollapse() -> h
    void mergeForceCollapse() -> i
    void mergeHi(int,int,int,int) -> j
    void mergeLo(int,int,int,int) -> k
    int minRunLength(int) -> l
    void pushRun(int,int) -> m
    void rangeCheck(int,int,int) -> n
    void reverseRange(java.lang.Object[],int,int) -> o
com.badlogic.gdx.utils.DelayedRemovalArray -> d0.g:
    int clear -> j
    int iterating -> h
    com.badlogic.gdx.utils.IntArray remove -> i
    void insert(int,java.lang.Object) -> i
    java.lang.Object removeIndex(int) -> l
    void removeRange(int,int) -> m
    boolean removeValue(java.lang.Object,boolean) -> n
    void sort() -> p
    void truncate(int) -> s
    void begin() -> u
    void end() -> v
    void remove(int) -> w
com.badlogic.gdx.utils.Disposable -> d0.h:
    void dispose() -> b
com.badlogic.gdx.utils.FloatArray -> d0.i:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray) -> b
    void addAll(com.badlogic.gdx.utils.FloatArray,int,int) -> c
    void addAll(float[],int,int) -> d
    void clear() -> e
    float[] ensureCapacity(int) -> f
    float first() -> g
    float get(int) -> h
    boolean notEmpty() -> i
    void removeRange(int,int) -> j
    float[] resize(int) -> k
    void truncate(int) -> l
com.badlogic.gdx.utils.GdxNativesLoader -> d0.j:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> d0.k:
com.badlogic.gdx.utils.I18NBundle -> d0.l:
    com.badlogic.gdx.utils.TextFormatter formatter -> d
    java.util.Locale locale -> b
    com.badlogic.gdx.utils.I18NBundle parent -> a
    java.util.Locale ROOT_LOCALE -> e
    boolean simpleFormatter -> f
    boolean exceptionOnMissingKey -> g
    com.badlogic.gdx.utils.ObjectMap properties -> c
    boolean checkFileExistence(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> b
    com.badlogic.gdx.utils.I18NBundle createBundleImpl(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> c
    java.lang.String get(java.lang.String) -> d
    java.util.List getCandidateLocales(java.util.Locale) -> e
    java.util.Locale getFallbackLocale(java.util.Locale) -> f
    java.util.Locale getLocale() -> g
    void load(java.io.Reader) -> h
    com.badlogic.gdx.utils.I18NBundle loadBundle(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.Locale) -> i
    com.badlogic.gdx.utils.I18NBundle loadBundleChain(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.List,int,com.badlogic.gdx.utils.I18NBundle) -> j
    void setLocale(java.util.Locale) -> k
    com.badlogic.gdx.files.FileHandle toFileHandle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> l
com.badlogic.gdx.utils.IntArray -> d0.m:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    void add(int,int) -> b
    void clear() -> c
    int[] ensureCapacity(int) -> d
    int get(int) -> e
    void insert(int,int) -> f
    int peek() -> g
    int pop() -> h
    int[] resize(int) -> i
    void set(int,int) -> j
    int[] toArray() -> k
com.badlogic.gdx.utils.IntIntMap -> d0.n:
    int[] valueTable -> f
    int mask -> l
    float loadFactor -> i
    int threshold -> j
    int shift -> k
    int[] keyTable -> e
    int zeroValue -> g
    int size -> d
    boolean hasZeroValue -> h
    com.badlogic.gdx.utils.IntIntMap$Entries entries2 -> n
    com.badlogic.gdx.utils.IntIntMap$Entries entries1 -> m
    boolean containsKey(int) -> a
    com.badlogic.gdx.utils.IntIntMap$Entries entries() -> b
    int get(int,int) -> c
    int locateKey(int) -> d
    int place(int) -> e
    void put(int,int) -> f
    void putResize(int,int) -> g
    int remove(int,int) -> h
    void resize(int) -> i
com.badlogic.gdx.utils.IntIntMap$Entries -> d0.n$a:
    com.badlogic.gdx.utils.IntIntMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.IntIntMap$Entry next() -> c
com.badlogic.gdx.utils.IntIntMap$Entry -> d0.n$b:
    int value -> b
    int key -> a
com.badlogic.gdx.utils.IntIntMap$MapIterator -> d0.n$c:
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    com.badlogic.gdx.utils.IntIntMap map -> e
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntMap -> d0.o:
    int mask -> l
    float loadFactor -> i
    int threshold -> j
    java.lang.Object zeroValue -> g
    int shift -> k
    int size -> d
    com.badlogic.gdx.utils.IntMap$Values values2 -> p
    com.badlogic.gdx.utils.IntMap$Values values1 -> o
    com.badlogic.gdx.utils.IntMap$Entries entries2 -> n
    int[] keyTable -> e
    com.badlogic.gdx.utils.IntMap$Entries entries1 -> m
    boolean hasZeroValue -> h
    java.lang.Object[] valueTable -> f
    void ensureCapacity(int) -> a
    com.badlogic.gdx.utils.IntMap$Entries entries() -> b
    java.lang.Object get(int,java.lang.Object) -> c
    int locateKey(int) -> d
    int place(int) -> e
    java.lang.Object put(int,java.lang.Object) -> f
    void putAll(com.badlogic.gdx.utils.IntMap) -> g
    void putResize(int,java.lang.Object) -> h
    void resize(int) -> i
    com.badlogic.gdx.utils.IntMap$Values values() -> j
com.badlogic.gdx.utils.IntMap$Entries -> d0.o$a:
    com.badlogic.gdx.utils.IntMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.IntMap$Entry next() -> c
com.badlogic.gdx.utils.IntMap$Entry -> d0.o$b:
    java.lang.Object value -> b
    int key -> a
com.badlogic.gdx.utils.IntMap$MapIterator -> d0.o$c:
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    com.badlogic.gdx.utils.IntMap map -> e
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntMap$Values -> d0.o$d:
    void reset() -> b
com.badlogic.gdx.utils.IntSet -> d0.p:
    int[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    boolean hasZeroValue -> c
    int size -> a
    boolean add(int) -> a
    void addResize(int) -> b
    boolean contains(int) -> c
    int locateKey(int) -> d
    int place(int) -> e
    boolean remove(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.Json -> d0.q:
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> m
    com.badlogic.gdx.utils.ObjectMap classToTag -> l
    com.badlogic.gdx.utils.ObjectMap tagToClass -> k
    com.badlogic.gdx.utils.ObjectMap typeToFields -> j
    com.badlogic.gdx.utils.ObjectMap classToDefaultValues -> n
    java.lang.Object[] equals2 -> p
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> c
    com.badlogic.gdx.utils.Json$Serializer defaultSerializer -> i
    java.lang.Object[] equals1 -> o
    boolean ignoreDeprecated -> e
    boolean readDeprecated -> f
    java.lang.String typeName -> a
    boolean enumNames -> g
    boolean sortFields -> h
    boolean usePrototypes -> b
    boolean ignoreUnknownFields -> d
    void addClassTag(java.lang.String,java.lang.Class) -> a
    java.lang.String convertToString(java.lang.Enum) -> b
    void copyFields(java.lang.Object,java.lang.Object) -> c
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> d
    java.lang.Class getClass(java.lang.String) -> e
    com.badlogic.gdx.utils.OrderedMap getFields(java.lang.Class) -> f
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> g
    java.lang.Object newInstance(java.lang.Class) -> h
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> i
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> j
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> k
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> l
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> m
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> n
    void setTypeName(java.lang.String) -> o
    void setUsePrototypes(boolean) -> p
    void sortFields(java.lang.Class,com.badlogic.gdx.utils.Array) -> q
com.badlogic.gdx.utils.Json$FieldMetadata -> d0.q$a:
    com.badlogic.gdx.utils.reflect.Field field -> a
    java.lang.Class elementType -> b
    boolean deprecated -> c
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> d0.q$b:
com.badlogic.gdx.utils.Json$Serializable -> d0.q$c:
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.utils.Json$Serializer -> d0.q$d:
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.utils.JsonReader -> d0.r:
    short[] _json_key_offsets -> g
    byte[] _json_eof_actions -> o
    com.badlogic.gdx.utils.Array elements -> a
    byte[] _json_indicies -> l
    short[] _json_index_offsets -> k
    byte[] _json_trans_actions -> n
    char[] _json_trans_keys -> h
    byte[] _json_trans_targs -> m
    com.badlogic.gdx.utils.JsonValue current -> d
    boolean stop -> e
    byte[] _json_range_lengths -> j
    com.badlogic.gdx.utils.Array lastChild -> b
    com.badlogic.gdx.utils.JsonValue root -> c
    byte[] _json_single_lengths -> i
    byte[] _json_actions -> f
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void bool(java.lang.String,boolean) -> b
    byte[] init__json_actions_0() -> c
    byte[] init__json_eof_actions_0() -> d
    short[] init__json_index_offsets_0() -> e
    byte[] init__json_indicies_0() -> f
    short[] init__json_key_offsets_0() -> g
    byte[] init__json_range_lengths_0() -> h
    byte[] init__json_single_lengths_0() -> i
    byte[] init__json_trans_actions_0() -> j
    char[] init__json_trans_keys_0() -> k
    byte[] init__json_trans_targs_0() -> l
    void number(java.lang.String,double,java.lang.String) -> m
    void number(java.lang.String,long,java.lang.String) -> n
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> o
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> p
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> q
    void pop() -> r
    void startArray(java.lang.String) -> s
    void startObject(java.lang.String) -> t
    void string(java.lang.String,java.lang.String) -> u
    java.lang.String unescape(java.lang.String) -> v
com.badlogic.gdx.utils.JsonValue -> d0.s:
    com.badlogic.gdx.utils.JsonValue$ValueType type -> d
    com.badlogic.gdx.utils.JsonValue prev -> l
    com.badlogic.gdx.utils.JsonValue parent -> j
    java.lang.String name -> h
    com.badlogic.gdx.utils.JsonValue next -> k
    int size -> m
    long longValue -> g
    double doubleValue -> f
    com.badlogic.gdx.utils.JsonValue child -> i
    java.lang.String stringValue -> e
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> A
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> B
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,int,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> C
    com.badlogic.gdx.utils.JsonValue remove(java.lang.String) -> D
    void set(double,java.lang.String) -> E
    void set(long,java.lang.String) -> F
    void set(java.lang.String) -> G
    void set(boolean) -> H
    void setName(java.lang.String) -> I
    java.lang.String trace() -> J
    boolean asBoolean() -> a
    byte asByte() -> b
    double asDouble() -> c
    float asFloat() -> d
    int asInt() -> e
    long asLong() -> f
    short asShort() -> g
    java.lang.String asString() -> h
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> i
    com.badlogic.gdx.utils.JsonValue getChild(java.lang.String) -> j
    java.lang.String getString(java.lang.String,java.lang.String) -> k
    boolean has(java.lang.String) -> l
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> m
    boolean isArray() -> n
    boolean isBoolean() -> o
    boolean isDouble() -> p
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> q
    boolean isLong() -> r
    boolean isNull() -> s
    boolean isNumber() -> t
    boolean isNumeric(com.badlogic.gdx.utils.JsonValue) -> u
    boolean isObject() -> v
    boolean isString() -> w
    boolean isValue() -> x
    com.badlogic.gdx.utils.JsonValue$JsonIterator iterator() -> y
    java.lang.String name() -> z
com.badlogic.gdx.utils.JsonValue$1 -> d0.s$a:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$JsonIterator -> d0.s$b:
    com.badlogic.gdx.utils.JsonValue entry -> d
    com.badlogic.gdx.utils.JsonValue current -> e
    com.badlogic.gdx.utils.JsonValue this$0 -> f
    com.badlogic.gdx.utils.JsonValue next() -> a
com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings -> d0.s$c:
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> a
    int singleLineColumns -> b
    boolean wrapNumericArrays -> c
com.badlogic.gdx.utils.JsonValue$ValueType -> d0.s$d:
    com.badlogic.gdx.utils.JsonValue$ValueType object -> d
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> h
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType array -> e
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> j
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> i
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> k
com.badlogic.gdx.utils.JsonWriter$1 -> d0.t:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> d0.u:
    java.util.regex.Pattern javascriptPattern -> g
    java.util.regex.Pattern minimalValuePattern -> i
    java.util.regex.Pattern minimalNamePattern -> h
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> e
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> j
    java.lang.String quoteName(java.lang.String) -> a
    java.lang.String quoteValue(java.lang.Object) -> b
com.badlogic.gdx.utils.LongMap -> d0.v:
    long[] keyTable -> e
    int mask -> l
    float loadFactor -> i
    int threshold -> j
    java.lang.Object zeroValue -> g
    int shift -> k
    com.badlogic.gdx.utils.LongMap$Values values1 -> o
    com.badlogic.gdx.utils.LongMap$Values values2 -> p
    int size -> d
    boolean hasZeroValue -> h
    java.lang.Object[] valueTable -> f
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> n
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> m
    com.badlogic.gdx.utils.LongMap$Entries entries() -> a
    java.lang.Object get(long) -> b
    java.lang.Object get(long,java.lang.Object) -> c
    int locateKey(long) -> d
    int place(long) -> e
    java.lang.Object put(long,java.lang.Object) -> f
    void putResize(long,java.lang.Object) -> g
    java.lang.Object remove(long) -> h
    void resize(int) -> i
    com.badlogic.gdx.utils.LongMap$Values values() -> j
com.badlogic.gdx.utils.LongMap$Entries -> d0.v$a:
    com.badlogic.gdx.utils.LongMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.LongMap$Entry next() -> c
com.badlogic.gdx.utils.LongMap$Entry -> d0.v$b:
    java.lang.Object value -> b
    long key -> a
com.badlogic.gdx.utils.LongMap$MapIterator -> d0.v$c:
    com.badlogic.gdx.utils.LongMap map -> e
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.LongMap$Values -> d0.v$d:
    void reset() -> b
com.badlogic.gdx.utils.NumberUtils -> d0.w:
    int floatToIntBits(float) -> a
    int floatToIntColor(float) -> b
    int floatToRawIntBits(float) -> c
    float intToFloatColor(int) -> d
com.badlogic.gdx.utils.ObjectFloatMap -> d0.x:
    java.lang.Object[] keyTable -> e
    int mask -> j
    float loadFactor -> g
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries2 -> l
    int threshold -> h
    int shift -> i
    float[] valueTable -> f
    int size -> d
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries1 -> k
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries() -> b
    float get(java.lang.Object,float) -> c
    com.badlogic.gdx.utils.ObjectFloatMap$Entries iterator() -> d
    int locateKey(java.lang.Object) -> e
    int place(java.lang.Object) -> f
    void put(java.lang.Object,float) -> g
    void putResize(java.lang.Object,float) -> h
    void resize(int) -> i
    java.lang.String toString(java.lang.String,boolean) -> j
com.badlogic.gdx.utils.ObjectFloatMap$Entries -> d0.x$a:
    com.badlogic.gdx.utils.ObjectFloatMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.ObjectFloatMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectFloatMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectFloatMap$Entry -> d0.x$b:
    float value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectFloatMap$MapIterator -> d0.x$c:
    com.badlogic.gdx.utils.ObjectFloatMap map -> e
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectIntMap -> d0.y:
    int[] valueTable -> f
    java.lang.Object[] keyTable -> e
    int mask -> j
    float loadFactor -> g
    int threshold -> h
    int shift -> i
    int size -> d
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> k
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> l
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> b
    int get(java.lang.Object,int) -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entries iterator() -> d
    int locateKey(java.lang.Object) -> e
    int place(java.lang.Object) -> f
    void put(java.lang.Object,int) -> g
    void putResize(java.lang.Object,int) -> h
    void resize(int) -> i
    java.lang.String toString(java.lang.String,boolean) -> j
com.badlogic.gdx.utils.ObjectIntMap$Entries -> d0.y$a:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.ObjectIntMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectIntMap$Entry -> d0.y$b:
    java.lang.Object key -> a
    int value -> b
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> d0.y$c:
    com.badlogic.gdx.utils.ObjectIntMap map -> e
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap -> d0.z:
    java.lang.Object[] keyTable -> e
    int mask -> j
    float loadFactor -> g
    int threshold -> h
    int shift -> i
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> n
    int size -> d
    java.lang.Object dummy -> q
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> m
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> o
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> p
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> k
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> l
    java.lang.Object[] valueTable -> f
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    java.lang.Object get(java.lang.Object) -> c
    java.lang.Object get(java.lang.Object,java.lang.Object) -> d
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> e
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> f
    int locateKey(java.lang.Object) -> g
    int place(java.lang.Object) -> h
    java.lang.Object put(java.lang.Object,java.lang.Object) -> i
    void putResize(java.lang.Object,java.lang.Object) -> j
    java.lang.Object remove(java.lang.Object) -> k
    void resize(int) -> l
    java.lang.String toString(java.lang.String,boolean) -> m
    com.badlogic.gdx.utils.ObjectMap$Values values() -> n
com.badlogic.gdx.utils.ObjectMap$Entries -> d0.z$a:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectMap$Entry -> d0.z$b:
    java.lang.Object value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectMap$Keys -> d0.z$c:
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Keys iterator() -> c
com.badlogic.gdx.utils.ObjectMap$MapIterator -> d0.z$d:
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    com.badlogic.gdx.utils.ObjectMap map -> e
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$Values -> d0.z$e:
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Values iterator() -> c
    com.badlogic.gdx.utils.Array toArray() -> d
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> e
com.badlogic.gdx.utils.ObjectSet -> d0.a0:
    java.lang.Object[] keyTable -> e
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator2 -> k
    float loadFactor -> f
    int shift -> h
    int mask -> i
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator1 -> j
    int threshold -> g
    int size -> d
    void addResize(java.lang.Object) -> a
    void clear(int) -> b
    void ensureCapacity(int) -> c
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> d
    int locateKey(java.lang.Object) -> e
    int place(java.lang.Object) -> f
    void resize(int) -> g
    int tableSize(int,float) -> h
    java.lang.String toString(java.lang.String) -> i
com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator -> d0.a0$a:
    int nextIndex -> f
    int currentIndex -> g
    com.badlogic.gdx.utils.ObjectSet set -> e
    boolean valid -> h
    boolean hasNext -> d
    void findNextIndex() -> a
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> b
    void reset() -> c
com.badlogic.gdx.utils.OrderedMap -> d0.b0:
    com.badlogic.gdx.utils.Array keys -> r
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> e
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> f
    java.lang.Object put(java.lang.Object,java.lang.Object) -> i
    java.lang.Object remove(java.lang.Object) -> k
    java.lang.String toString(java.lang.String,boolean) -> m
    com.badlogic.gdx.utils.ObjectMap$Values values() -> n
    java.lang.Object removeIndex(int) -> o
com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries -> d0.b0$a:
    com.badlogic.gdx.utils.Array keys -> j
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys -> d0.b0$b:
    com.badlogic.gdx.utils.Array keys -> i
    void reset() -> b
com.badlogic.gdx.utils.OrderedMap$OrderedMapValues -> d0.b0$c:
    com.badlogic.gdx.utils.Array keys -> i
    void reset() -> b
    com.badlogic.gdx.utils.Array toArray() -> d
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> e
com.badlogic.gdx.utils.OrderedSet -> d0.c0:
    com.badlogic.gdx.utils.Array items -> l
    com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator iterator2 -> n
    com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator iterator1 -> m
    void clear(int) -> b
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> d
    java.lang.String toString(java.lang.String) -> i
    void addAll(com.badlogic.gdx.utils.OrderedSet) -> j
    com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator iterator() -> k
    java.lang.Object removeIndex(int) -> l
com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator -> d0.c0$a:
    com.badlogic.gdx.utils.Array items -> i
    void reset() -> c
com.badlogic.gdx.utils.Pool -> d0.d0:
    com.badlogic.gdx.utils.Array freeObjects -> c
    int peak -> b
    int max -> a
    void discard(java.lang.Object) -> a
    void free(java.lang.Object) -> b
    void freeAll(com.badlogic.gdx.utils.Array) -> c
    java.lang.Object newObject() -> d
    java.lang.Object obtain() -> e
    void reset(java.lang.Object) -> f
com.badlogic.gdx.utils.Pool$Poolable -> d0.d0$a:
com.badlogic.gdx.utils.Pools -> d0.e0:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array,boolean) -> b
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> c
    com.badlogic.gdx.utils.Pool get(java.lang.Class,int) -> d
    java.lang.Object obtain(java.lang.Class) -> e
com.badlogic.gdx.utils.PropertiesUtils -> d0.f0:
    void load(com.badlogic.gdx.utils.ObjectMap,java.io.Reader) -> a
com.badlogic.gdx.utils.Queue -> d0.g0:
    java.lang.Object[] values -> d
    int tail -> f
    int size -> g
    int head -> e
    com.badlogic.gdx.utils.Queue$QueueIterable iterable -> h
    java.lang.Object removeIndex(int) -> a
    void resize(int) -> b
com.badlogic.gdx.utils.Queue$QueueIterable -> d0.g0$a:
    com.badlogic.gdx.utils.Queue$QueueIterator iterator1 -> f
    com.badlogic.gdx.utils.Queue$QueueIterator iterator2 -> g
    com.badlogic.gdx.utils.Queue queue -> d
    boolean allowRemove -> e
com.badlogic.gdx.utils.Queue$QueueIterator -> d0.g0$b:
    com.badlogic.gdx.utils.Queue queue -> d
    boolean allowRemove -> e
    int index -> f
    boolean valid -> g
com.badlogic.gdx.utils.ReflectionPool -> d0.h0:
    com.badlogic.gdx.utils.reflect.Constructor constructor -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.utils.reflect.Constructor findConstructor(java.lang.Class) -> g
com.badlogic.gdx.utils.Scaling -> d0.i0:
    com.badlogic.gdx.utils.Scaling stretch -> g
    com.badlogic.gdx.utils.Scaling fillY -> f
    com.badlogic.gdx.math.Vector2 temp -> a
    com.badlogic.gdx.utils.Scaling fillX -> e
    com.badlogic.gdx.utils.Scaling fill -> d
    com.badlogic.gdx.utils.Scaling contain -> c
    com.badlogic.gdx.utils.Scaling fit -> b
    com.badlogic.gdx.utils.Scaling none -> j
    com.badlogic.gdx.utils.Scaling stretchY -> i
    com.badlogic.gdx.utils.Scaling stretchX -> h
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> d0.i0$a:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$2 -> d0.i0$b:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$3 -> d0.i0$c:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$4 -> d0.i0$d:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$5 -> d0.i0$e:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$6 -> d0.i0$f:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$7 -> d0.i0$g:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$8 -> d0.i0$h:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$9 -> d0.i0$i:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.SerializationException -> d0.j0:
    com.badlogic.gdx.utils.StringBuilder trace -> d
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoadRuntimeException -> d0.k0:
com.badlogic.gdx.utils.SharedLibraryLoader -> d0.l0:
    java.util.Random random -> j
    boolean isIos -> e
    boolean isAndroid -> f
    java.lang.String nativesJar -> a
    boolean isARM -> g
    boolean is64Bit -> h
    boolean isWindows -> b
    boolean isLinux -> c
    boolean isMac -> d
    java.util.HashSet loadedLibraries -> i
    void closeQuietly(java.io.Closeable) -> a
    java.lang.String crc(java.io.InputStream) -> b
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> c
    boolean isLoaded(java.lang.String) -> d
    void load(java.lang.String) -> e
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> f
    void loadFile(java.lang.String) -> g
    java.lang.String mapLibraryName(java.lang.String) -> h
    java.io.InputStream readFile(java.lang.String) -> i
    void setLoaded(java.lang.String) -> j
com.badlogic.gdx.utils.SnapshotArray -> d0.m0:
    int snapshots -> j
    java.lang.Object[] snapshot -> h
    java.lang.Object[] recycled -> i
    void insert(int,java.lang.Object) -> i
    java.lang.Object removeIndex(int) -> l
    void removeRange(int,int) -> m
    boolean removeValue(java.lang.Object,boolean) -> n
    void sort() -> p
    void truncate(int) -> s
    java.lang.Object[] begin() -> u
    void end() -> v
    void modified() -> w
com.badlogic.gdx.utils.Sort -> d0.n0:
    com.badlogic.gdx.utils.TimSort timSort -> a
    com.badlogic.gdx.utils.Sort instance -> c
    com.badlogic.gdx.utils.ComparableTimSort comparableTimSort -> b
    com.badlogic.gdx.utils.Sort instance() -> a
    void sort(java.lang.Object[],int,int) -> b
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> c
com.badlogic.gdx.utils.StreamUtils -> d0.o0:
    byte[] EMPTY_BYTES -> a
    void closeQuietly(java.io.Closeable) -> a
    int copyStream(java.io.InputStream,java.nio.ByteBuffer,byte[]) -> b
    void copyStream(java.io.InputStream,java.io.OutputStream) -> c
    void copyStream(java.io.InputStream,java.io.OutputStream,byte[]) -> d
    void copyStream(java.io.InputStream,java.nio.ByteBuffer) -> e
    byte[] copyStreamToByteArray(java.io.InputStream,int) -> f
com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream -> d0.o0$a:
com.badlogic.gdx.utils.StringBuilder -> d0.p0:
    char[] chars -> d
    char[] digits -> f
    int length -> e
    void insert0(int,java.lang.String) -> A
    void move(int,int) -> B
    int numChars(int,int) -> C
    int numChars(long,int) -> D
    com.badlogic.gdx.utils.StringBuilder replace(char,java.lang.String) -> E
    void replace0(int,int,java.lang.String) -> F
    void setLength(int) -> G
    java.lang.String substring(int,int) -> H
    com.badlogic.gdx.utils.StringBuilder append(char) -> a
    com.badlogic.gdx.utils.StringBuilder append(double) -> b
    com.badlogic.gdx.utils.StringBuilder append(float) -> c
    com.badlogic.gdx.utils.StringBuilder append(int) -> d
    com.badlogic.gdx.utils.StringBuilder append(int,int) -> e
    com.badlogic.gdx.utils.StringBuilder append(int,int,char) -> f
    com.badlogic.gdx.utils.StringBuilder append(long) -> g
    com.badlogic.gdx.utils.StringBuilder append(long,int) -> h
    com.badlogic.gdx.utils.StringBuilder append(long,int,char) -> i
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder) -> j
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> k
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> l
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> m
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> n
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> o
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> p
    com.badlogic.gdx.utils.StringBuilder append(char[],int,int) -> q
    void append0(char) -> r
    void append0(java.lang.CharSequence,int,int) -> s
    void append0(java.lang.String) -> t
    void append0(char[]) -> u
    void append0(char[],int,int) -> v
    void appendNull() -> w
    void enlargeBuffer(int) -> x
    int indexOf(java.lang.String) -> y
    int indexOf(java.lang.String,int) -> z
com.badlogic.gdx.utils.TextFormatter -> d0.q0:
    com.badlogic.gdx.utils.StringBuilder buffer -> b
    java.text.MessageFormat messageFormat -> a
com.badlogic.gdx.utils.TimSort -> d0.r0:
    java.lang.Object[] tmp -> d
    int[] runBase -> g
    int[] runLen -> h
    int stackSize -> f
    int tmpCount -> e
    int minGallop -> c
    java.util.Comparator c -> b
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> b
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> c
    java.lang.Object[] ensureCapacity(int) -> d
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> e
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> f
    void mergeAt(int) -> g
    void mergeCollapse() -> h
    void mergeForceCollapse() -> i
    void mergeHi(int,int,int,int) -> j
    void mergeLo(int,int,int,int) -> k
    int minRunLength(int) -> l
    void pushRun(int,int) -> m
    void rangeCheck(int,int,int) -> n
    void reverseRange(java.lang.Object[],int,int) -> o
com.badlogic.gdx.utils.TimeUtils -> d0.s0:
    long millis() -> a
    long nanoTime() -> b
com.badlogic.gdx.utils.Timer -> d0.t0:
    com.badlogic.gdx.utils.Timer$TimerThread thread -> c
    com.badlogic.gdx.utils.Array tasks -> a
    java.lang.Object threadLock -> b
    void delay(long) -> a
    com.badlogic.gdx.utils.Timer instance() -> b
    com.badlogic.gdx.utils.Timer$Task schedule(com.badlogic.gdx.utils.Timer$Task,float) -> c
    com.badlogic.gdx.utils.Timer$Task schedule(com.badlogic.gdx.utils.Timer$Task,float,float) -> d
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float) -> e
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float) -> f
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> g
    void start() -> h
    com.badlogic.gdx.utils.Timer$TimerThread thread() -> i
    long update(long,long) -> j
com.badlogic.gdx.utils.Timer$Task -> d0.t0$a:
    long intervalMillis -> f
    long executeTimeMillis -> e
    int repeatCount -> g
    com.badlogic.gdx.Application app -> d
    com.badlogic.gdx.utils.Timer timer -> h
    void cancel() -> a
    boolean isScheduled() -> b
com.badlogic.gdx.utils.Timer$TimerThread -> d0.t0$b:
    long pauseTimeMillis -> h
    com.badlogic.gdx.utils.Timer instance -> g
    com.badlogic.gdx.Files files -> d
    com.badlogic.gdx.Application app -> e
    com.badlogic.gdx.utils.Array instances -> f
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.utils.XmlReader -> d0.u0:
    com.badlogic.gdx.utils.Array elements -> a
    byte[] _xml_indicies -> l
    short[] _xml_index_offsets -> k
    byte[] _xml_trans_actions -> n
    com.badlogic.gdx.utils.XmlReader$Element current -> c
    char[] _xml_trans_keys -> h
    byte[] _xml_trans_targs -> m
    com.badlogic.gdx.utils.XmlReader$Element root -> b
    com.badlogic.gdx.utils.StringBuilder textBuffer -> d
    byte[] _xml_key_offsets -> g
    byte[] _xml_range_lengths -> j
    byte[] _xml_single_lengths -> i
    java.lang.String entitiesText -> e
    byte[] _xml_actions -> f
    void attribute(java.lang.String,java.lang.String) -> a
    void close() -> b
    java.lang.String entity(java.lang.String) -> c
    byte[] init__xml_actions_0() -> d
    short[] init__xml_index_offsets_0() -> e
    byte[] init__xml_indicies_0() -> f
    byte[] init__xml_key_offsets_0() -> g
    byte[] init__xml_range_lengths_0() -> h
    byte[] init__xml_single_lengths_0() -> i
    byte[] init__xml_trans_actions_0() -> j
    char[] init__xml_trans_keys_0() -> k
    byte[] init__xml_trans_targs_0() -> l
    void open(java.lang.String) -> m
    com.badlogic.gdx.utils.XmlReader$Element parse(java.io.Reader) -> n
    com.badlogic.gdx.utils.XmlReader$Element parse(com.badlogic.gdx.files.FileHandle) -> o
    com.badlogic.gdx.utils.XmlReader$Element parse(char[],int,int) -> p
    void text(java.lang.String) -> q
com.badlogic.gdx.utils.XmlReader$Element -> d0.u0$a:
    com.badlogic.gdx.utils.XmlReader$Element parent -> e
    java.lang.String name -> a
    com.badlogic.gdx.utils.Array children -> c
    com.badlogic.gdx.utils.ObjectMap attributes -> b
    java.lang.String text -> d
    void addChild(com.badlogic.gdx.utils.XmlReader$Element) -> a
    java.lang.String get(java.lang.String,java.lang.String) -> b
    java.lang.String getAttribute(java.lang.String) -> c
    java.lang.String getAttribute(java.lang.String,java.lang.String) -> d
    com.badlogic.gdx.utils.XmlReader$Element getChild(int) -> e
    com.badlogic.gdx.utils.XmlReader$Element getChildByName(java.lang.String) -> f
    int getChildCount() -> g
    com.badlogic.gdx.utils.Array getChildrenByName(java.lang.String) -> h
    float getFloatAttribute(java.lang.String,float) -> i
    int getIntAttribute(java.lang.String) -> j
    int getIntAttribute(java.lang.String,int) -> k
    java.lang.String getName() -> l
    java.lang.String getText() -> m
    boolean hasAttribute(java.lang.String) -> n
    void removeChild(com.badlogic.gdx.utils.XmlReader$Element) -> o
    void setAttribute(java.lang.String,java.lang.String) -> p
    void setText(java.lang.String) -> q
    java.lang.String toString(java.lang.String) -> r
com.badlogic.gdx.utils.reflect.ArrayReflection -> e0.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
    void set(java.lang.Object,int,java.lang.Object) -> b
com.badlogic.gdx.utils.reflect.ClassReflection -> e0.b:
    java.lang.Class forName(java.lang.String) -> a
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> b
    com.badlogic.gdx.utils.reflect.Constructor getDeclaredConstructor(java.lang.Class,java.lang.Class[]) -> c
    com.badlogic.gdx.utils.reflect.Field[] getDeclaredFields(java.lang.Class) -> d
    java.lang.String getSimpleName(java.lang.Class) -> e
    boolean isAssignableFrom(java.lang.Class,java.lang.Class) -> f
    boolean isInstance(java.lang.Class,java.lang.Object) -> g
    boolean isMemberClass(java.lang.Class) -> h
    boolean isStaticClass(java.lang.Class) -> i
    java.lang.Object newInstance(java.lang.Class) -> j
com.badlogic.gdx.utils.reflect.Constructor -> e0.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    java.lang.Object newInstance(java.lang.Object[]) -> b
    void setAccessible(boolean) -> c
com.badlogic.gdx.utils.reflect.Field -> e0.d:
    java.lang.reflect.Field field -> a
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Class getDeclaringClass() -> b
    java.lang.Class getElementType(int) -> c
    java.lang.String getName() -> d
    java.lang.Class getType() -> e
    boolean isAccessible() -> f
    boolean isAnnotationPresent(java.lang.Class) -> g
    boolean isStatic() -> h
    boolean isSynthetic() -> i
    boolean isTransient() -> j
    void set(java.lang.Object,java.lang.Object) -> k
    void setAccessible(boolean) -> l
com.badlogic.gdx.utils.reflect.ReflectionException -> e0.e:
com.badlogic.gdx.utils.viewport.ExtendViewport -> f0.a:
    float maxWorldHeight -> l
    float maxWorldWidth -> k
    float minWorldHeight -> j
    float minWorldWidth -> i
    com.badlogic.gdx.utils.Scaling scaling -> m
    void update(int,int,boolean) -> p
com.badlogic.gdx.utils.viewport.FillViewport -> f0.b:
com.badlogic.gdx.utils.viewport.ScalingViewport -> f0.c:
    com.badlogic.gdx.utils.Scaling scaling -> i
    void update(int,int,boolean) -> p
com.badlogic.gdx.utils.viewport.ScreenViewport -> f0.d:
    float unitsPerPixel -> i
    void update(int,int,boolean) -> p
com.badlogic.gdx.utils.viewport.Viewport -> f0.e:
    com.badlogic.gdx.graphics.Camera camera -> a
    int screenWidth -> f
    float worldHeight -> c
    int screenHeight -> g
    float worldWidth -> b
    int screenX -> d
    int screenY -> e
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply() -> a
    void apply(boolean) -> b
    void calculateScissors(com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> c
    com.badlogic.gdx.graphics.Camera getCamera() -> d
    int getScreenHeight() -> e
    int getScreenWidth() -> f
    int getScreenX() -> g
    int getScreenY() -> h
    float getWorldHeight() -> i
    float getWorldWidth() -> j
    void setCamera(com.badlogic.gdx.graphics.Camera) -> k
    void setScreenBounds(int,int,int,int) -> l
    void setWorldSize(float,float) -> m
    com.badlogic.gdx.math.Vector2 unproject(com.badlogic.gdx.math.Vector2) -> n
    void update(int,int) -> o
    void update(int,int,boolean) -> p
com.insearchoftheperfectcuisine.game.Main -> g0.a:
    float unitScale -> b
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    void resize(int,int) -> d
    void create() -> e
    void render() -> f
com.insearchoftheperfectcuisine.game.entities.Entity -> h0.a:
    com.badlogic.gdx.math.Vector2 position -> d
    com.badlogic.gdx.physics.box2d.Body body -> b
    com.badlogic.gdx.physics.box2d.World world -> c
    com.badlogic.gdx.graphics.Texture texture -> a
    com.badlogic.gdx.math.Vector2 size -> e
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void update() -> b
com.insearchoftheperfectcuisine.game.entities.Player -> h0.b:
    java.lang.String playerName -> f
    float moveSpeed -> h
    int playerId -> g
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void update() -> b
    void handleInput() -> c
com.insearchoftheperfectcuisine.game.screens.BaseScreen -> i0.a:
    com.badlogic.gdx.Game game -> a
com.insearchoftheperfectcuisine.game.screens.PlayGameScreen -> i0.b:
    com.badlogic.gdx.physics.box2d.World world -> h
    float unitScale -> j
    com.badlogic.gdx.utils.viewport.Viewport viewport -> d
    com.insearchoftheperfectcuisine.game.entities.Player player -> g
    com.badlogic.gdx.graphics.Texture playerTexture -> i
    com.badlogic.gdx.graphics.OrthographicCamera camera -> c
    com.insearchoftheperfectcuisine.game.Main main -> f
    com.insearchoftheperfectcuisine.game.systems.MapR mapR -> b
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> e
    void pause() -> a
    void show() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render(float) -> e
    void hide() -> f
    void draw() -> g
    void update() -> h
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen -> j0.a:
    com.badlogic.gdx.Game game -> b
    com.insearchoftheperfectcuisine.game.Main main -> g
    com.insearchoftheperfectcuisine.game.systems.GameSettings gameSettings -> c
    float unitScale -> h
    com.badlogic.gdx.scenes.scene2d.Stage stage -> d
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> e
    com.badlogic.gdx.utils.viewport.Viewport stageViewport -> i
    com.badlogic.gdx.utils.viewport.Viewport batchViewport -> j
    com.badlogic.gdx.graphics.g2d.Sprite backgroundSprite -> n
    com.badlogic.gdx.graphics.OrthographicCamera camera -> k
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> l
    com.badlogic.gdx.scenes.scene2d.ui.Label titleLabel -> f
    com.badlogic.gdx.audio.Sound hoverSound -> p
    com.badlogic.gdx.scenes.scene2d.ui.Table mainMenuTable -> o
    com.badlogic.gdx.graphics.Texture backgroundTexture -> m
    void pause() -> a
    void show() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render(float) -> e
    void hide() -> f
    com.badlogic.gdx.Game access$000(com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen) -> g
    com.badlogic.gdx.scenes.scene2d.Stage access$100(com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen) -> h
    void draw() -> i
    void update() -> j
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$1 -> j0.a$a:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> b
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$2 -> j0.a$b:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$3 -> j0.a$c:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$4 -> j0.a$d:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$5 -> j0.a$e:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$6 -> j0.a$f:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$6$1 -> j0.a$f$a:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$6 this$1 -> d
com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen$7 -> j0.a$g:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.MainMenuScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen -> j0.b:
    com.badlogic.gdx.Game game -> b
    com.badlogic.gdx.scenes.scene2d.ui.Label fullscreenLabel -> u
    float unitScale -> g
    com.badlogic.gdx.scenes.scene2d.ui.Label titleLabel -> s
    com.badlogic.gdx.scenes.scene2d.Stage stage -> d
    com.badlogic.gdx.scenes.scene2d.ui.TextButton graphicsButton -> T
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table innerTable -> r
    com.badlogic.gdx.scenes.scene2d.ui.TextButton controlsButton -> V
    com.insearchoftheperfectcuisine.game.Main main -> f
    com.badlogic.gdx.utils.viewport.Viewport batchViewport -> i
    com.badlogic.gdx.graphics.g2d.Sprite backgroundSprite -> m
    com.badlogic.gdx.scenes.scene2d.ui.TextField fpsTextField -> z
    com.badlogic.gdx.scenes.scene2d.ui.Label languageLabel -> L
    com.badlogic.gdx.graphics.OrthographicCamera camera -> j
    java.lang.String[] languageOptions -> M
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane leftInnerTableScroll -> Q
    com.badlogic.gdx.scenes.scene2d.ui.Table innerScrollTableLeft -> P
    com.badlogic.gdx.scenes.scene2d.ui.Table rootTable -> o
    com.badlogic.gdx.scenes.scene2d.ui.Table[] rightInnerTables -> J
    com.badlogic.gdx.scenes.scene2d.ui.Table graphicsInnerTable -> B
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox fullscreenCheckbox -> v
    com.badlogic.gdx.scenes.scene2d.ui.Table controlInnerTable -> D
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox vsyncCheckbox -> x
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane generalScrollPane -> E
    com.badlogic.gdx.scenes.scene2d.ui.Table generalScrollTable -> F
    com.badlogic.gdx.scenes.scene2d.ui.Table soundScrollTable -> H
    com.insearchoftheperfectcuisine.game.systems.GameSettings gameSettings -> c
    com.badlogic.gdx.scenes.scene2d.ui.TextButton generalButton -> S
    com.badlogic.gdx.scenes.scene2d.ui.TextButton soundButton -> U
    com.badlogic.gdx.scenes.scene2d.ui.Table outerTableLeft -> q
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane scrollPane -> t
    com.badlogic.gdx.scenes.scene2d.ui.Label generalTitleLabel -> K
    com.badlogic.gdx.utils.viewport.Viewport stageViewport -> h
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> k
    com.badlogic.gdx.scenes.scene2d.ui.Table controlScrollTable -> I
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox languageSelect -> N
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane leftOuterTableScroll -> R
    com.badlogic.gdx.scenes.scene2d.ui.Table outerTableRight -> p
    com.badlogic.gdx.audio.Sound hoverSound -> n
    com.badlogic.gdx.scenes.scene2d.ui.Table innerTableLeft -> O
    com.badlogic.gdx.scenes.scene2d.ui.Label fpsLabel -> y
    com.badlogic.gdx.scenes.scene2d.ui.Table generalInnerTable -> A
    int settingsShow -> W
    com.badlogic.gdx.scenes.scene2d.ui.Label vsyncLabel -> w
    com.badlogic.gdx.graphics.Texture backgroundTexture -> l
    com.badlogic.gdx.scenes.scene2d.ui.Table soundInnerTable -> C
    com.badlogic.gdx.scenes.scene2d.ui.Table graphicsScrollTable -> G
    void pause() -> a
    void show() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render(float) -> e
    void hide() -> f
    com.insearchoftheperfectcuisine.game.systems.GameSettings access$000(com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen) -> g
    com.badlogic.gdx.scenes.scene2d.Stage access$100(com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen) -> h
    com.badlogic.gdx.Game access$200(com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen) -> i
    void draw() -> j
    void update() -> k
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$1 -> j0.b$h:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> b
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$10 -> j0.b$a:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$10$1 -> j0.b$a$a:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$10 this$1 -> d
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$11 -> j0.b$b:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$12 -> j0.b$c:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$13 -> j0.b$d:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$14 -> j0.b$e:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$15 -> j0.b$f:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$16 -> j0.b$g:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$2 -> j0.b$i:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$3 -> j0.b$j:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$4 -> j0.b$k:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$5 -> j0.b$l:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$6 -> j0.b$m:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$7 -> j0.b$n:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$8 -> j0.b$o:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen$9 -> j0.b$p:
    com.insearchoftheperfectcuisine.game.screens.mainMenu.newSettingsScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.insearchoftheperfectcuisine.game.systems.GameSettings -> k0.a:
    com.badlogic.gdx.Preferences preferences -> g
    java.lang.String language -> f
    int fps -> e
    int screenHeight -> b
    boolean fullscreen -> c
    int screenWidth -> a
    boolean vSync -> d
    int getFps() -> a
    java.lang.String getLanguage() -> b
    boolean getVsync() -> c
    boolean isFullscreen() -> d
    void loadSettings() -> e
    void saveSettings() -> f
    void setDefaultSettings() -> g
    void setFps(int) -> h
    void setFullscreen(boolean) -> i
    void setLanguage(java.lang.String) -> j
    void setResolution(int,int) -> k
    void setUserSettings() -> l
    void setVsync(boolean) -> m
com.insearchoftheperfectcuisine.game.systems.MapR -> k0.b:
    com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer renderer -> a
    float unitScale -> c
    com.badlogic.gdx.maps.tiled.TiledMap map -> b
    void render(com.badlogic.gdx.graphics.OrthographicCamera) -> a
com.insearchoftheperfectcuisine.game.utils.LocalizationManager -> l0.a:
    com.badlogic.gdx.files.FileHandle baseFileHandle -> a
    java.util.Locale locale -> b
    com.badlogic.gdx.utils.I18NBundle myBundle -> c
    java.lang.String get(java.lang.String) -> a
    void load(java.lang.String) -> b
com.ray3k.stripe.FreeTypeSkin -> m0.a:
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> J
com.ray3k.stripe.FreeTypeSkin$1 -> m0.a$a:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    com.ray3k.stripe.FreeTypeSkin this$0 -> c
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
kotlin.ExceptionsKt -> n0.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ExceptionsKt__ExceptionsKt -> n0.b:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
kotlin.KotlinNothingValueException -> n0.c:
kotlin.Pair -> n0.d:
    java.lang.Object first -> d
    java.lang.Object second -> e
    java.lang.Object component1() -> a
    java.lang.Object component2() -> b
    java.lang.Object getFirst() -> c
    java.lang.Object getSecond() -> d
kotlin.Result -> n0.e:
    kotlin.Result$Companion Companion -> d
    java.lang.Object constructor-impl(java.lang.Object) -> a
    java.lang.Throwable exceptionOrNull-impl(java.lang.Object) -> b
    boolean isFailure-impl(java.lang.Object) -> c
    boolean isSuccess-impl(java.lang.Object) -> d
kotlin.Result$Companion -> n0.e$a:
kotlin.Result$Failure -> n0.e$b:
    java.lang.Throwable exception -> d
kotlin.ResultKt -> n0.f:
    java.lang.Object createFailure(java.lang.Throwable) -> a
kotlin.TuplesKt -> n0.g:
    kotlin.Pair to(java.lang.Object,java.lang.Object) -> a
kotlin.UninitializedPropertyAccessException -> n0.h:
kotlin.Unit -> n0.i:
    kotlin.Unit INSTANCE -> a
kotlin.collections.ArraysKt -> o0.a:
    java.lang.Object[] copyInto$default(java.lang.Object[],java.lang.Object[],int,int,int,int,java.lang.Object) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    char single(char[]) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object singleOrNull(java.lang.Object[]) -> e
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.ArraysKt__ArraysJVMKt -> o0.b:
kotlin.collections.ArraysKt__ArraysKt -> o0.c:
kotlin.collections.ArraysKt___ArraysJvmKt -> o0.d:
    java.util.List asList(java.lang.Object[]) -> a
    java.lang.Object[] copyInto(java.lang.Object[],java.lang.Object[],int,int,int) -> b
    java.lang.Object[] copyInto$default(java.lang.Object[],java.lang.Object[],int,int,int,int,java.lang.Object) -> c
kotlin.collections.ArraysKt___ArraysKt -> o0.e:
    char single(char[]) -> d
    java.lang.Object singleOrNull(java.lang.Object[]) -> e
kotlin.collections.ArraysUtilJVM -> o0.f:
    java.util.List asList(java.lang.Object[]) -> a
kotlin.collections.CollectionsKt -> o0.g:
    java.util.List listOf(java.lang.Object[]) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List optimizeReadOnlyList(java.util.List) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    void throwIndexOverflow() -> e
      # {"id":"com.android.tools.r8.synthesized"}
    int collectionSizeOrDefault(java.lang.Iterable,int) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    boolean addAll(java.util.Collection,java.lang.Iterable) -> g
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List toList(java.lang.Iterable) -> i
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Set toSet(java.lang.Iterable) -> l
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.CollectionsKt__CollectionsJVMKt -> o0.h:
    java.util.List listOf(java.lang.Object) -> a
kotlin.collections.CollectionsKt__CollectionsKt -> o0.i:
    java.util.List emptyList() -> b
    java.util.List listOf(java.lang.Object[]) -> c
    java.util.List optimizeReadOnlyList(java.util.List) -> d
    void throwIndexOverflow() -> e
kotlin.collections.CollectionsKt__IterablesKt -> o0.j:
    int collectionSizeOrDefault(java.lang.Iterable,int) -> f
kotlin.collections.CollectionsKt__IteratorsJVMKt -> o0.k:
kotlin.collections.CollectionsKt__IteratorsKt -> o0.l:
kotlin.collections.CollectionsKt__MutableCollectionsJVMKt -> o0.m:
kotlin.collections.CollectionsKt__MutableCollectionsKt -> o0.n:
    boolean addAll(java.util.Collection,java.lang.Iterable) -> g
kotlin.collections.CollectionsKt__ReversedViewsKt -> o0.o:
kotlin.collections.CollectionsKt___CollectionsJvmKt -> o0.p:
kotlin.collections.CollectionsKt___CollectionsKt -> o0.q:
    java.util.Collection toCollection(java.lang.Iterable,java.util.Collection) -> h
    java.util.List toList(java.lang.Iterable) -> i
    java.util.List toMutableList(java.lang.Iterable) -> j
    java.util.List toMutableList(java.util.Collection) -> k
    java.util.Set toSet(java.lang.Iterable) -> l
kotlin.collections.EmptyIterator -> o0.r:
    kotlin.collections.EmptyIterator INSTANCE -> d
    java.lang.Void next() -> a
    java.lang.Void previous() -> b
kotlin.collections.EmptyList -> o0.s:
    kotlin.collections.EmptyList INSTANCE -> d
    boolean contains(java.lang.Void) -> a
    java.lang.Void get(int) -> b
    int getSize() -> c
    int indexOf(java.lang.Void) -> d
    int lastIndexOf(java.lang.Void) -> e
kotlin.collections.EmptyMap -> o0.t:
    kotlin.collections.EmptyMap INSTANCE -> d
    boolean containsValue(java.lang.Void) -> a
    java.lang.Void get(java.lang.Object) -> b
    java.util.Set getEntries() -> c
    java.util.Set getKeys() -> d
    int getSize() -> e
    java.util.Collection getValues() -> f
    java.lang.Void remove(java.lang.Object) -> g
kotlin.collections.EmptySet -> o0.u:
    kotlin.collections.EmptySet INSTANCE -> d
    boolean contains(java.lang.Void) -> a
    int getSize() -> b
kotlin.collections.IntIterator -> o0.v:
kotlin.collections.MapsKt -> o0.w:
    int mapCapacity(int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Map toMap(java.lang.Iterable) -> g
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.MapsKt__MapWithDefaultKt -> o0.x:
kotlin.collections.MapsKt__MapsJVMKt -> o0.y:
    int mapCapacity(int) -> a
    java.util.Map mapOf(kotlin.Pair) -> b
    java.util.Map toSingletonMap(java.util.Map) -> c
kotlin.collections.MapsKt__MapsKt -> o0.z:
    java.util.Map emptyMap() -> d
    java.util.Map optimizeReadOnlyMap(java.util.Map) -> e
    void putAll(java.util.Map,java.lang.Iterable) -> f
    java.util.Map toMap(java.lang.Iterable) -> g
    java.util.Map toMap(java.lang.Iterable,java.util.Map) -> h
kotlin.collections.MapsKt___MapsKt -> o0.a0:
kotlin.collections.SetsKt__SetsJVMKt -> o0.b0:
    java.util.Set setOf(java.lang.Object) -> a
kotlin.collections.SetsKt__SetsKt -> o0.c0:
    java.util.Set emptySet() -> b
    java.util.Set optimizeReadOnlySet(java.util.Set) -> c
kotlin.coroutines.AbstractCoroutineContextElement -> p0.a:
kotlin.coroutines.AbstractCoroutineContextKey -> p0.b:
    kotlin.coroutines.CoroutineContext$Key topmostKey -> e
    kotlin.jvm.functions.Function1 safeCast -> d
    boolean isSubKey$kotlin_stdlib(kotlin.coroutines.CoroutineContext$Key) -> a
    kotlin.coroutines.CoroutineContext$Element tryCast$kotlin_stdlib(kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.CombinedContext -> p0.c:
    kotlin.coroutines.CoroutineContext$Element element -> e
    kotlin.coroutines.CoroutineContext left -> d
    boolean contains(kotlin.coroutines.CoroutineContext$Element) -> c
    boolean containsAll(kotlin.coroutines.CombinedContext) -> h
    int size() -> l
kotlin.coroutines.CombinedContext$toString$1 -> p0.c$a:
    kotlin.coroutines.CombinedContext$toString$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    java.lang.String invoke(java.lang.String,kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.Continuation -> p0.d:
    kotlin.coroutines.CoroutineContext getContext() -> c
    void resumeWith(java.lang.Object) -> l
kotlin.coroutines.ContinuationInterceptor -> p0.e:
    kotlin.coroutines.ContinuationInterceptor$Key Key -> c
    kotlin.coroutines.Continuation interceptContinuation(kotlin.coroutines.Continuation) -> i
    void releaseInterceptedContinuation(kotlin.coroutines.Continuation) -> j
kotlin.coroutines.ContinuationInterceptor$DefaultImpls -> p0.e$a:
    kotlin.coroutines.CoroutineContext$Element get(kotlin.coroutines.ContinuationInterceptor,kotlin.coroutines.CoroutineContext$Key) -> a
    kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.ContinuationInterceptor,kotlin.coroutines.CoroutineContext$Key) -> b
kotlin.coroutines.ContinuationInterceptor$Key -> p0.e$b:
    kotlin.coroutines.ContinuationInterceptor$Key $$INSTANCE -> d
kotlin.coroutines.CoroutineContext -> p0.f:
kotlin.coroutines.CoroutineContext$DefaultImpls -> p0.f$a:
    kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext) -> a
kotlin.coroutines.CoroutineContext$Element -> p0.f$b:
kotlin.coroutines.CoroutineContext$Element$DefaultImpls -> p0.f$b$a:
    java.lang.Object fold(kotlin.coroutines.CoroutineContext$Element,java.lang.Object,kotlin.jvm.functions.Function2) -> a
    kotlin.coroutines.CoroutineContext$Element get(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext$Key) -> b
    kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext$Key) -> c
    kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext) -> d
kotlin.coroutines.CoroutineContext$Key -> p0.f$c:
kotlin.coroutines.CoroutineContext$plus$1 -> p0.f$a$a:
    kotlin.coroutines.CoroutineContext$plus$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    kotlin.coroutines.CoroutineContext invoke(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.EmptyCoroutineContext -> p0.g:
    kotlin.coroutines.EmptyCoroutineContext INSTANCE -> d
kotlin.coroutines.intrinsics.CoroutineSingletons -> q0.a:
    kotlin.coroutines.intrinsics.CoroutineSingletons UNDECIDED -> e
    kotlin.coroutines.intrinsics.CoroutineSingletons RESUMED -> f
    kotlin.coroutines.intrinsics.CoroutineSingletons COROUTINE_SUSPENDED -> d
    kotlin.coroutines.intrinsics.CoroutineSingletons[] $VALUES -> g
    kotlin.coroutines.intrinsics.CoroutineSingletons[] $values() -> a
kotlin.coroutines.intrinsics.IntrinsicsKt -> q0.b:
    kotlin.coroutines.Continuation intercepted(kotlin.coroutines.Continuation) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object getCOROUTINE_SUSPENDED() -> b
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt -> q0.c:
    kotlin.coroutines.Continuation intercepted(kotlin.coroutines.Continuation) -> a
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsKt -> q0.d:
    java.lang.Object getCOROUTINE_SUSPENDED() -> b
kotlin.coroutines.jvm.internal.BaseContinuationImpl -> r0.a:
    kotlin.coroutines.Continuation completion -> d
    java.lang.StackTraceElement getStackTraceElement() -> a
    java.lang.Object invokeSuspend(java.lang.Object) -> b
    void releaseIntercepted() -> d
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> h
    void resumeWith(java.lang.Object) -> l
kotlin.coroutines.jvm.internal.CompletedContinuation -> r0.b:
    kotlin.coroutines.jvm.internal.CompletedContinuation INSTANCE -> d
    kotlin.coroutines.CoroutineContext getContext() -> c
    void resumeWith(java.lang.Object) -> l
kotlin.coroutines.jvm.internal.ContinuationImpl -> r0.c:
    kotlin.coroutines.CoroutineContext _context -> e
    kotlin.coroutines.Continuation intercepted -> f
    kotlin.coroutines.CoroutineContext getContext() -> c
    void releaseIntercepted() -> d
    kotlin.coroutines.Continuation intercepted() -> e
kotlin.coroutines.jvm.internal.CoroutineStackFrame -> r0.d:
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> h
kotlin.coroutines.jvm.internal.DebugMetadata -> r0.e:
kotlin.coroutines.jvm.internal.DebugMetadataKt -> r0.f:
    void checkDebugMetadataVersion(int,int) -> a
    kotlin.coroutines.jvm.internal.DebugMetadata getDebugMetadataAnnotation(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> b
    int getLabel(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> c
    java.lang.StackTraceElement getStackTraceElement(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> d
kotlin.coroutines.jvm.internal.DebugProbesKt -> r0.g:
    void probeCoroutineResumed(kotlin.coroutines.Continuation) -> a
kotlin.coroutines.jvm.internal.ModuleNameRetriever -> r0.h:
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache notOnJava9 -> b
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache cache -> c
    kotlin.coroutines.jvm.internal.ModuleNameRetriever INSTANCE -> a
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache buildCache(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> a
    java.lang.String getModuleName(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> b
kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache -> r0.h$a:
    java.lang.reflect.Method nameMethod -> c
    java.lang.reflect.Method getModuleMethod -> a
    java.lang.reflect.Method getDescriptorMethod -> b
kotlin.internal.PlatformImplementations -> s0.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
    kotlin.random.Random defaultPlatformRandom() -> b
kotlin.internal.PlatformImplementations$ReflectThrowable -> s0.a$a:
    kotlin.internal.PlatformImplementations$ReflectThrowable INSTANCE -> a
    java.lang.reflect.Method getSuppressed -> c
    java.lang.reflect.Method addSuppressed -> b
kotlin.internal.PlatformImplementationsKt -> s0.b:
    kotlin.internal.PlatformImplementations IMPLEMENTATIONS -> a
    int getJavaVersion() -> a
kotlin.internal.ProgressionUtilKt -> s0.c:
    int differenceModulo(int,int,int) -> a
    int getProgressionLastElement(int,int,int) -> b
    int mod(int,int) -> c
kotlin.internal.jdk7.JDK7PlatformImplementations -> t0.b:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
kotlin.internal.jdk7.JDK7PlatformImplementations$$ExternalSyntheticBackport0 -> t0.a:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    void kotlin.internal.jdk7.JDK7PlatformImplementations$$InternalSyntheticBackport$1$5dd1ba9cbabf516c5421f68beb3d2c44b2f996bdb40194921c2a266ab2276b61$0.m(java.lang.Throwable,java.lang.Throwable) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.internal.jdk8.JDK8PlatformImplementations -> u0.a:
    kotlin.random.Random defaultPlatformRandom() -> b
kotlin.io.CloseableKt -> v0.a:
    void closeFinally(java.io.Closeable,java.lang.Throwable) -> a
kotlin.jvm.JvmClassMappingKt -> w0.a:
    java.lang.Class getJavaObjectType(kotlin.reflect.KClass) -> a
kotlin.jvm.functions.Function0 -> x0.a:
kotlin.jvm.functions.Function1 -> x0.l:
    java.lang.Object invoke(java.lang.Object) -> e
kotlin.jvm.functions.Function10 -> x0.b:
kotlin.jvm.functions.Function11 -> x0.c:
kotlin.jvm.functions.Function12 -> x0.d:
kotlin.jvm.functions.Function13 -> x0.e:
kotlin.jvm.functions.Function14 -> x0.f:
kotlin.jvm.functions.Function15 -> x0.g:
kotlin.jvm.functions.Function16 -> x0.h:
kotlin.jvm.functions.Function17 -> x0.i:
kotlin.jvm.functions.Function18 -> x0.j:
kotlin.jvm.functions.Function19 -> x0.k:
kotlin.jvm.functions.Function2 -> x0.p:
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
kotlin.jvm.functions.Function20 -> x0.m:
kotlin.jvm.functions.Function21 -> x0.n:
kotlin.jvm.functions.Function22 -> x0.o:
kotlin.jvm.functions.Function3 -> x0.q:
kotlin.jvm.functions.Function4 -> x0.r:
kotlin.jvm.functions.Function5 -> x0.s:
kotlin.jvm.functions.Function6 -> x0.t:
kotlin.jvm.functions.Function7 -> x0.u:
kotlin.jvm.functions.Function8 -> x0.v:
kotlin.jvm.functions.Function9 -> x0.w:
kotlin.jvm.internal.CallableReference -> y0.a:
    java.lang.Class owner -> f
    java.lang.String name -> g
    java.lang.Object NO_RECEIVER -> j
    java.lang.String signature -> h
    boolean isTopLevel -> i
    java.lang.Object receiver -> e
    kotlin.reflect.KCallable reflected -> d
    kotlin.reflect.KCallable compute() -> a
    kotlin.reflect.KCallable computeReflected() -> b
    java.lang.Object getBoundReceiver() -> c
    java.lang.String getName() -> d
    kotlin.reflect.KDeclarationContainer getOwner() -> e
    java.lang.String getSignature() -> f
kotlin.jvm.internal.CallableReference$NoReceiver -> y0.a$a:
    kotlin.jvm.internal.CallableReference$NoReceiver INSTANCE -> d
    kotlin.jvm.internal.CallableReference$NoReceiver access$000() -> a
kotlin.jvm.internal.ClassBasedDeclarationContainer -> y0.b:
    java.lang.Class getJClass() -> a
kotlin.jvm.internal.ClassReference -> y0.c:
    java.util.Map FUNCTION_CLASSES -> c
    kotlin.jvm.internal.ClassReference$Companion Companion -> b
    java.util.HashMap classFqNames -> f
    java.lang.Class jClass -> a
    java.util.HashMap primitiveWrapperFqNames -> e
    java.util.HashMap primitiveFqNames -> d
    java.util.Map simpleNames -> g
    java.lang.Class getJClass() -> a
kotlin.jvm.internal.ClassReference$Companion -> y0.c$a:
kotlin.jvm.internal.CollectionToArray -> y0.d:
    java.lang.Object[] EMPTY -> a
    java.lang.Object[] toArray(java.util.Collection) -> a
    java.lang.Object[] toArray(java.util.Collection,java.lang.Object[]) -> b
kotlin.jvm.internal.DefaultConstructorMarker -> y0.e:
kotlin.jvm.internal.FunctionBase -> y0.f:
kotlin.jvm.internal.Intrinsics -> y0.g:
    boolean areEqual(java.lang.Object,java.lang.Object) -> a
    void checkNotNull(java.lang.Object) -> b
    void checkNotNullExpressionValue(java.lang.Object,java.lang.String) -> c
    void checkNotNullParameter(java.lang.Object,java.lang.String) -> d
    int compare(int,int) -> e
    java.lang.String createParameterIsNullExceptionMessage(java.lang.String) -> f
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable) -> g
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable,java.lang.String) -> h
    java.lang.String stringPlus(java.lang.String,java.lang.Object) -> i
    void throwJavaNpe() -> j
    void throwParameterIsNullNPE(java.lang.String) -> k
    void throwUninitializedProperty(java.lang.String) -> l
    void throwUninitializedPropertyAccessException(java.lang.String) -> m
kotlin.jvm.internal.Lambda -> y0.h:
    int arity -> d
kotlin.jvm.internal.PackageReference -> y0.i:
    java.lang.Class jClass -> a
    java.lang.String moduleName -> b
    java.lang.Class getJClass() -> a
kotlin.jvm.internal.PropertyReference -> y0.l:
kotlin.jvm.internal.PropertyReference0 -> y0.j:
    kotlin.reflect.KCallable computeReflected() -> b
kotlin.jvm.internal.PropertyReference0Impl -> y0.k:
kotlin.jvm.internal.Reflection -> y0.m:
    kotlin.reflect.KClass[] EMPTY_K_CLASS_ARRAY -> b
    kotlin.jvm.internal.ReflectionFactory factory -> a
    kotlin.reflect.KClass getOrCreateKotlinClass(java.lang.Class) -> a
    kotlin.reflect.KDeclarationContainer getOrCreateKotlinPackage(java.lang.Class) -> b
    kotlin.reflect.KProperty0 property0(kotlin.jvm.internal.PropertyReference0) -> c
    java.lang.String renderLambdaToString(kotlin.jvm.internal.Lambda) -> d
kotlin.jvm.internal.ReflectionFactory -> y0.n:
    kotlin.reflect.KClass getOrCreateKotlinClass(java.lang.Class) -> a
    kotlin.reflect.KDeclarationContainer getOrCreateKotlinPackage(java.lang.Class,java.lang.String) -> b
    kotlin.reflect.KProperty0 property0(kotlin.jvm.internal.PropertyReference0) -> c
    java.lang.String renderLambdaToString(kotlin.jvm.internal.FunctionBase) -> d
    java.lang.String renderLambdaToString(kotlin.jvm.internal.Lambda) -> e
kotlin.random.AbstractPlatformRandom -> z0.a:
    int nextInt() -> b
    java.util.Random getImpl() -> c
kotlin.random.FallbackThreadLocalRandom -> z0.b:
    kotlin.random.FallbackThreadLocalRandom$implStorage$1 implStorage -> f
    java.util.Random getImpl() -> c
kotlin.random.FallbackThreadLocalRandom$implStorage$1 -> z0.b$a:
    java.util.Random initialValue() -> a
kotlin.random.Random -> z0.c:
    kotlin.random.Random$Default Default -> d
    kotlin.random.Random defaultRandom -> e
    kotlin.random.Random access$getDefaultRandom$cp() -> a
    int nextInt() -> b
kotlin.random.Random$Default -> z0.c$a:
    int nextInt() -> b
kotlin.random.jdk8.PlatformThreadLocalRandom -> a1.a:
    java.util.Random getImpl() -> c
kotlin.ranges.IntProgression -> b1.a:
    kotlin.ranges.IntProgression$Companion Companion -> g
    int step -> f
    int first -> d
    int last -> e
    int getFirst() -> a
    int getLast() -> b
    int getStep() -> c
    kotlin.collections.IntIterator iterator() -> d
kotlin.ranges.IntProgression$Companion -> b1.a$a:
    kotlin.ranges.IntProgression fromClosedRange(int,int,int) -> a
kotlin.ranges.IntProgressionIterator -> b1.b:
    boolean hasNext -> f
    int next -> g
    int step -> d
    int finalElement -> e
kotlin.ranges.IntRange -> b1.c:
    kotlin.ranges.IntRange$Companion Companion -> h
    kotlin.ranges.IntRange EMPTY -> i
kotlin.ranges.IntRange$Companion -> b1.c$a:
kotlin.ranges.RangesKt -> b1.d:
    int coerceAtLeast(int,int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    long coerceAtLeast(long,long) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    int coerceAtMost(int,int) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    long coerceAtMost(long,long) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.ranges.IntProgression downTo(int,int) -> e
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ranges.RangesKt__RangesKt -> b1.e:
kotlin.ranges.RangesKt___RangesKt -> b1.f:
    int coerceAtLeast(int,int) -> a
    long coerceAtLeast(long,long) -> b
    int coerceAtMost(int,int) -> c
    long coerceAtMost(long,long) -> d
    kotlin.ranges.IntProgression downTo(int,int) -> e
kotlin.reflect.KCallable -> c1.a:
kotlin.reflect.KClass -> c1.b:
kotlin.reflect.KDeclarationContainer -> c1.c:
kotlin.reflect.KProperty -> c1.e:
kotlin.reflect.KProperty0 -> c1.d:
kotlin.sequences.ConstrainedOnceSequence -> d1.a:
    java.util.concurrent.atomic.AtomicReference sequenceRef -> a
kotlin.sequences.Sequence -> d1.b:
kotlin.sequences.SequencesKt -> d1.c:
    kotlin.sequences.Sequence asSequence(java.util.Iterator) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List toList(kotlin.sequences.Sequence) -> d
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.sequences.SequencesKt__SequenceBuilderKt -> d1.d:
kotlin.sequences.SequencesKt__SequencesJVMKt -> d1.e:
kotlin.sequences.SequencesKt__SequencesKt -> d1.f:
    kotlin.sequences.Sequence asSequence(java.util.Iterator) -> a
    kotlin.sequences.Sequence constrainOnce(kotlin.sequences.Sequence) -> b
kotlin.sequences.SequencesKt__SequencesKt$asSequence$$inlined$Sequence$1 -> d1.f$a:
    java.util.Iterator $this_asSequence$inlined -> a
kotlin.sequences.SequencesKt___SequencesJvmKt -> d1.g:
kotlin.sequences.SequencesKt___SequencesKt -> d1.h:
    java.util.Collection toCollection(kotlin.sequences.Sequence,java.util.Collection) -> c
    java.util.List toList(kotlin.sequences.Sequence) -> d
    java.util.List toMutableList(kotlin.sequences.Sequence) -> e
kotlin.text.CharsKt__CharJVMKt -> e1.a:
    int checkRadix(int) -> a
    int digitOf(char,int) -> b
    boolean isWhitespace(char) -> c
kotlin.text.CharsKt__CharKt -> e1.b:
    boolean equals(char,char,boolean) -> d
kotlin.text.StringsKt -> e1.c:
    java.lang.Long toLongOrNull(java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    boolean startsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    int indexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> k
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfter$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> s
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfterLast$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> u
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringBefore$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> x
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringBefore$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> y
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.CharSequence trim(java.lang.CharSequence) -> z
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.text.StringsKt__AppendableKt -> e1.d:
kotlin.text.StringsKt__IndentKt -> e1.e:
kotlin.text.StringsKt__RegexExtensionsJVMKt -> e1.f:
kotlin.text.StringsKt__RegexExtensionsKt -> e1.g:
kotlin.text.StringsKt__StringBuilderJVMKt -> e1.h:
kotlin.text.StringsKt__StringBuilderKt -> e1.i:
kotlin.text.StringsKt__StringNumberConversionsJVMKt -> e1.j:
kotlin.text.StringsKt__StringNumberConversionsKt -> e1.k:
    java.lang.Long toLongOrNull(java.lang.String) -> a
    java.lang.Long toLongOrNull(java.lang.String,int) -> b
kotlin.text.StringsKt__StringsJVMKt -> e1.l:
    boolean regionMatches(java.lang.String,int,java.lang.String,int,int,boolean) -> c
    boolean startsWith(java.lang.String,java.lang.String,boolean) -> d
    boolean startsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> e
kotlin.text.StringsKt__StringsKt -> e1.m:
    int getLastIndex(java.lang.CharSequence) -> f
    int indexOf(java.lang.CharSequence,char,int,boolean) -> g
    int indexOf(java.lang.CharSequence,java.lang.String,int,boolean) -> h
    int indexOf$StringsKt__StringsKt(java.lang.CharSequence,java.lang.CharSequence,int,int,boolean,boolean) -> i
    int indexOf$StringsKt__StringsKt$default(java.lang.CharSequence,java.lang.CharSequence,int,int,boolean,boolean,int,java.lang.Object) -> j
    int indexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> k
    int indexOf$default(java.lang.CharSequence,java.lang.String,int,boolean,int,java.lang.Object) -> l
    int indexOfAny(java.lang.CharSequence,char[],int,boolean) -> m
    int lastIndexOf(java.lang.CharSequence,char,int,boolean) -> n
    int lastIndexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> o
    int lastIndexOfAny(java.lang.CharSequence,char[],int,boolean) -> p
    boolean regionMatchesImpl(java.lang.CharSequence,int,java.lang.CharSequence,int,int,boolean) -> q
    java.lang.String substringAfter(java.lang.String,java.lang.String,java.lang.String) -> r
    java.lang.String substringAfter$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> s
    java.lang.String substringAfterLast(java.lang.String,char,java.lang.String) -> t
    java.lang.String substringAfterLast$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> u
    java.lang.String substringBefore(java.lang.String,char,java.lang.String) -> v
    java.lang.String substringBefore(java.lang.String,java.lang.String,java.lang.String) -> w
    java.lang.String substringBefore$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> x
    java.lang.String substringBefore$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> y
    java.lang.CharSequence trim(java.lang.CharSequence) -> z
kotlin.text.StringsKt___StringsJvmKt -> e1.n:
kotlin.text.StringsKt___StringsKt -> e1.o:
kotlinx.coroutines.AbstractCoroutine -> f1.a:
    kotlin.coroutines.CoroutineContext context -> e
    void handleOnCompletionException$kotlinx_coroutines_core(java.lang.Throwable) -> L
    java.lang.String nameString$kotlinx_coroutines_core() -> Q
    void onCompletionInternal(java.lang.Object) -> V
    boolean isActive() -> a
    kotlin.coroutines.CoroutineContext getContext() -> c
    void afterResume(java.lang.Object) -> j0
    void onCancelled(java.lang.Throwable,boolean) -> k0
    void resumeWith(java.lang.Object) -> l
    void onCompleted(java.lang.Object) -> l0
    java.lang.String cancellationExceptionMessage() -> w
kotlinx.coroutines.AbstractTimeSource -> f1.b:
kotlinx.coroutines.AbstractTimeSourceKt -> f1.c:
    kotlinx.coroutines.AbstractTimeSource getTimeSource() -> a
kotlinx.coroutines.BlockingEventLoop -> f1.d:
    java.lang.Thread thread -> j
    java.lang.Thread getThread() -> w
kotlinx.coroutines.CancelHandler -> f1.e:
kotlinx.coroutines.CancelHandlerBase -> f1.f:
    void invoke(java.lang.Throwable) -> a
kotlinx.coroutines.CancellableContinuation -> f1.g:
kotlinx.coroutines.CancellableContinuationImpl -> f1.i:
    kotlin.coroutines.CoroutineContext context -> h
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _decision$FU -> j
    kotlin.coroutines.Continuation delegate -> g
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _state$FU -> k
    kotlinx.coroutines.DisposableHandle parentHandle -> i
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    kotlin.coroutines.CoroutineContext getContext() -> c
    java.lang.Throwable getExceptionalResult$kotlinx_coroutines_core(java.lang.Object) -> d
    java.lang.Object getSuccessfulResult$kotlinx_coroutines_core(java.lang.Object) -> e
    java.lang.Object takeState$kotlinx_coroutines_core() -> g
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> h
    java.lang.Void alreadyResumedError(java.lang.Object) -> i
    void callCancelHandler(kotlinx.coroutines.CancelHandler,java.lang.Throwable) -> j
    void callOnCancellation(kotlin.jvm.functions.Function1,java.lang.Throwable) -> k
    void resumeWith(java.lang.Object) -> l
    void detachChild$kotlinx_coroutines_core() -> m
    void detachChildIfNonResuable() -> n
    void dispatchResume(int) -> o
    java.lang.Object getState$kotlinx_coroutines_core() -> p
    java.lang.String getStateDebugRepresentation() -> q
    boolean isReusable() -> r
    java.lang.String nameString() -> s
    void resumeImpl(java.lang.Object,int,kotlin.jvm.functions.Function1) -> t
    void resumeImpl$default(kotlinx.coroutines.CancellableContinuationImpl,java.lang.Object,int,kotlin.jvm.functions.Function1,int,java.lang.Object) -> u
    java.lang.Object resumedState(kotlinx.coroutines.NotCompleted,java.lang.Object,int,kotlin.jvm.functions.Function1,java.lang.Object) -> v
    boolean tryResume() -> w
kotlinx.coroutines.CancellableContinuationImpl$$ExternalSyntheticBackportWithForwarding0 -> f1.h:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean kotlinx.coroutines.CancellableContinuationImpl$$InternalSyntheticBackportWithForwarding$1$14938e86c53bbc417d960c3db093d9c528eee461fa47b6759be891f884702045$0.m(java.util.concurrent.atomic.AtomicReferenceFieldUpdater,java.lang.Object,java.lang.Object,java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlinx.coroutines.CancelledContinuation -> f1.j:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _resumed$FU -> c
    boolean makeResumed() -> c
kotlinx.coroutines.ChildHandle -> f1.k:
    boolean childCancelled(java.lang.Throwable) -> c
kotlinx.coroutines.ChildHandleNode -> f1.l:
    kotlinx.coroutines.ChildJob childJob -> h
    boolean childCancelled(java.lang.Throwable) -> c
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.ChildJob -> f1.m:
    void parentCancelled(kotlinx.coroutines.ParentJob) -> f
kotlinx.coroutines.CompletedContinuation -> f1.n:
    kotlinx.coroutines.CancelHandler cancelHandler -> b
    java.lang.Object idempotentResume -> d
    java.lang.Object result -> a
    java.lang.Throwable cancelCause -> e
    kotlin.jvm.functions.Function1 onCancellation -> c
    kotlinx.coroutines.CompletedContinuation copy(java.lang.Object,kotlinx.coroutines.CancelHandler,kotlin.jvm.functions.Function1,java.lang.Object,java.lang.Throwable) -> a
    kotlinx.coroutines.CompletedContinuation copy$default(kotlinx.coroutines.CompletedContinuation,java.lang.Object,kotlinx.coroutines.CancelHandler,kotlin.jvm.functions.Function1,java.lang.Object,java.lang.Throwable,int,java.lang.Object) -> b
    boolean getCancelled() -> c
    void invokeHandlers(kotlinx.coroutines.CancellableContinuationImpl,java.lang.Throwable) -> d
kotlinx.coroutines.CompletedExceptionally -> f1.o:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _handled$FU -> b
    java.lang.Throwable cause -> a
    boolean getHandled() -> a
    boolean makeHandled() -> b
kotlinx.coroutines.CompletedWithCancellation -> f1.p:
    java.lang.Object result -> a
    kotlin.jvm.functions.Function1 onCancellation -> b
kotlinx.coroutines.CompletionHandlerBase -> f1.q:
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.CompletionHandlerException -> f1.r:
kotlinx.coroutines.CompletionStateKt -> f1.s:
    java.lang.Object recoverResult(java.lang.Object,kotlin.coroutines.Continuation) -> a
    java.lang.Object toState(java.lang.Object,kotlinx.coroutines.CancellableContinuation) -> b
    java.lang.Object toState(java.lang.Object,kotlin.jvm.functions.Function1) -> c
    java.lang.Object toState$default(java.lang.Object,kotlin.jvm.functions.Function1,int,java.lang.Object) -> d
kotlinx.coroutines.CoroutineContextKt -> f1.t:
    java.lang.String getCoroutineName(kotlin.coroutines.CoroutineContext) -> a
    kotlinx.coroutines.UndispatchedCoroutine undispatchedCompletion(kotlin.coroutines.jvm.internal.CoroutineStackFrame) -> b
    kotlinx.coroutines.UndispatchedCoroutine updateUndispatchedCompletion(kotlin.coroutines.Continuation,kotlin.coroutines.CoroutineContext,java.lang.Object) -> c
kotlinx.coroutines.CoroutineDispatcher -> f1.u:
    kotlinx.coroutines.CoroutineDispatcher$Key Key -> d
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> h
    kotlin.coroutines.Continuation interceptContinuation(kotlin.coroutines.Continuation) -> i
    void releaseInterceptedContinuation(kotlin.coroutines.Continuation) -> j
    kotlinx.coroutines.CoroutineDispatcher limitedParallelism(int) -> l
kotlinx.coroutines.CoroutineDispatcher$Key -> f1.u$a:
kotlinx.coroutines.CoroutineDispatcher$Key$1 -> f1.u$a$a:
    kotlinx.coroutines.CoroutineDispatcher$Key$1 INSTANCE -> e
    kotlinx.coroutines.CoroutineDispatcher invoke(kotlin.coroutines.CoroutineContext$Element) -> b
    java.lang.Object invoke(java.lang.Object) -> e
kotlinx.coroutines.CoroutineExceptionHandler -> f1.v:
    kotlinx.coroutines.CoroutineExceptionHandler$Key Key -> a
kotlinx.coroutines.CoroutineExceptionHandler$Key -> f1.v$a:
    kotlinx.coroutines.CoroutineExceptionHandler$Key $$INSTANCE -> d
kotlinx.coroutines.CoroutineExceptionHandlerImplKt -> f1.w:
    java.util.List handlers -> a
    void handleCoroutineExceptionImpl(kotlin.coroutines.CoroutineContext,java.lang.Throwable) -> a
kotlinx.coroutines.CoroutineExceptionHandlerKt -> f1.x:
    void handleCoroutineException(kotlin.coroutines.CoroutineContext,java.lang.Throwable) -> a
    java.lang.Throwable handlerException(java.lang.Throwable,java.lang.Throwable) -> b
kotlinx.coroutines.CoroutinesInternalError -> f1.y:
kotlinx.coroutines.DebugStringsKt -> f1.z:
    java.lang.String getClassSimpleName(java.lang.Object) -> a
    java.lang.String getHexAddress(java.lang.Object) -> b
    java.lang.String toDebugString(kotlin.coroutines.Continuation) -> c
kotlinx.coroutines.DefaultExecutor -> f1.a0:
    kotlinx.coroutines.DefaultExecutor INSTANCE -> j
    long KEEP_ALIVE_NANOS -> k
    void enqueue(java.lang.Runnable) -> C
    void acknowledgeShutdownIfNeeded() -> N
    java.lang.Thread createThreadSync() -> O
    boolean isShutDown() -> P
    boolean isShutdownRequested() -> Q
    boolean notifyStartup() -> R
    void shutdownError() -> S
    java.lang.Thread getThread() -> w
    void reschedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> x
kotlinx.coroutines.DefaultExecutorKt -> f1.b0:
    kotlinx.coroutines.Delay DefaultDelay -> b
    boolean defaultMainDelayOptIn -> a
    kotlinx.coroutines.Delay getDefaultDelay() -> a
    kotlinx.coroutines.Delay initializeDefaultDelay() -> b
kotlinx.coroutines.Delay -> f1.c0:
kotlinx.coroutines.DiagnosticCoroutineContextException -> f1.d0:
    kotlin.coroutines.CoroutineContext context -> d
kotlinx.coroutines.DispatchedCoroutine -> f1.e0:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _decision$FU -> g
    void afterResume(java.lang.Object) -> j0
    boolean tryResume() -> m0
    void afterCompletion(java.lang.Object) -> r
kotlinx.coroutines.DispatchedTask -> f1.f0:
    int resumeMode -> f
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    java.lang.Throwable getExceptionalResult$kotlinx_coroutines_core(java.lang.Object) -> d
    java.lang.Object getSuccessfulResult$kotlinx_coroutines_core(java.lang.Object) -> e
    void handleFatalException(java.lang.Throwable,java.lang.Throwable) -> f
    java.lang.Object takeState$kotlinx_coroutines_core() -> g
kotlinx.coroutines.DispatchedTaskKt -> f1.g0:
    void dispatch(kotlinx.coroutines.DispatchedTask,int) -> a
    boolean isCancellableMode(int) -> b
    boolean isReusableMode(int) -> c
    void resume(kotlinx.coroutines.DispatchedTask,kotlin.coroutines.Continuation,boolean) -> d
    void resumeUnconfined(kotlinx.coroutines.DispatchedTask) -> e
kotlinx.coroutines.Dispatchers -> f1.h0:
    kotlinx.coroutines.Dispatchers INSTANCE -> a
    kotlinx.coroutines.CoroutineDispatcher IO -> d
    kotlinx.coroutines.CoroutineDispatcher Unconfined -> c
    kotlinx.coroutines.CoroutineDispatcher Default -> b
    kotlinx.coroutines.CoroutineDispatcher getIO() -> a
    kotlinx.coroutines.MainCoroutineDispatcher getMain() -> b
kotlinx.coroutines.DisposableHandle -> f1.i0:
    void dispose() -> b
kotlinx.coroutines.Empty -> f1.j0:
    boolean isActive -> d
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> d
kotlinx.coroutines.EventLoop -> f1.k0:
    long useCount -> e
    boolean shared -> f
    kotlinx.coroutines.internal.ArrayQueue unconfinedQueue -> g
    void decrementUseCount(boolean) -> n
    long delta(boolean) -> o
    void dispatchUnconfined(kotlinx.coroutines.DispatchedTask) -> p
    long getNextTime() -> q
    void incrementUseCount(boolean) -> r
    void incrementUseCount$default(kotlinx.coroutines.EventLoop,boolean,int,java.lang.Object) -> s
    boolean isUnconfinedLoopActive() -> t
    boolean isUnconfinedQueueEmpty() -> u
    boolean processUnconfinedEvent() -> v
kotlinx.coroutines.EventLoopImplBase -> f1.l0:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _queue$FU -> h
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _delayed$FU -> i
    void closeQueue() -> A
    java.lang.Runnable dequeue() -> B
    void enqueue(java.lang.Runnable) -> C
    boolean enqueueImpl(java.lang.Runnable) -> D
    boolean isCompleted() -> E
    boolean isEmpty() -> F
    long processNextEvent() -> G
    void rescheduleAllDelayed() -> H
    void resetAll() -> I
    void schedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> J
    int scheduleImpl(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> K
    void setCompleted(boolean) -> L
    boolean shouldUnpark(kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> M
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    long getNextTime() -> q
    boolean access$isCompleted(kotlinx.coroutines.EventLoopImplBase) -> z
kotlinx.coroutines.EventLoopImplBase$DelayedTask -> f1.l0$a:
    java.lang.Object _heap -> e
    int index -> f
    long nanoTime -> d
    void setHeap(kotlinx.coroutines.internal.ThreadSafeHeap) -> a
    void dispose() -> b
    kotlinx.coroutines.internal.ThreadSafeHeap getHeap() -> d
    int compareTo(kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> e
    int scheduleTask(long,kotlinx.coroutines.EventLoopImplBase$DelayedTaskQueue,kotlinx.coroutines.EventLoopImplBase) -> f
    boolean timeToExecute(long) -> g
kotlinx.coroutines.EventLoopImplBase$DelayedTaskQueue -> f1.l0$b:
    long timeNow -> b
kotlinx.coroutines.EventLoopImplPlatform -> f1.m0:
    java.lang.Thread getThread() -> w
    void reschedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> x
    void unpark() -> y
kotlinx.coroutines.EventLoopKt -> f1.n0:
    kotlinx.coroutines.EventLoop createEventLoop() -> a
kotlinx.coroutines.EventLoop_commonKt -> f1.o0:
    kotlinx.coroutines.internal.Symbol DISPOSED_TASK -> a
    kotlinx.coroutines.internal.Symbol CLOSED_EMPTY -> b
    kotlinx.coroutines.internal.Symbol access$getCLOSED_EMPTY$p() -> a
    kotlinx.coroutines.internal.Symbol access$getDISPOSED_TASK$p() -> b
kotlinx.coroutines.ExecutorCoroutineDispatcher -> f1.p0:
    kotlinx.coroutines.ExecutorCoroutineDispatcher$Key Key -> e
kotlinx.coroutines.ExecutorCoroutineDispatcher$Key -> f1.p0$a:
kotlinx.coroutines.ExecutorCoroutineDispatcher$Key$1 -> f1.p0$a$a:
    kotlinx.coroutines.ExecutorCoroutineDispatcher$Key$1 INSTANCE -> e
    kotlinx.coroutines.ExecutorCoroutineDispatcher invoke(kotlin.coroutines.CoroutineContext$Element) -> b
    java.lang.Object invoke(java.lang.Object) -> e
kotlinx.coroutines.InactiveNodeList -> f1.q0:
    kotlinx.coroutines.NodeList list -> d
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> d
kotlinx.coroutines.Incomplete -> f1.r0:
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> d
kotlinx.coroutines.IncompleteStateBox -> f1.s0:
    kotlinx.coroutines.Incomplete state -> a
kotlinx.coroutines.InvokeOnCancelling -> f1.t0:
    kotlin.jvm.functions.Function1 handler -> h
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _invoked$FU -> i
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.InvokeOnCompletion -> f1.u0:
    kotlin.jvm.functions.Function1 handler -> h
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.Job -> f1.v0:
    kotlinx.coroutines.Job$Key Key -> b
    boolean isActive() -> a
    kotlinx.coroutines.DisposableHandle invokeOnCompletion(boolean,boolean,kotlin.jvm.functions.Function1) -> b
    java.util.concurrent.CancellationException getCancellationException() -> g
    void cancel(java.util.concurrent.CancellationException) -> m
kotlinx.coroutines.Job$DefaultImpls -> f1.v0$a:
    java.lang.Object fold(kotlinx.coroutines.Job,java.lang.Object,kotlin.jvm.functions.Function2) -> a
    kotlin.coroutines.CoroutineContext$Element get(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext$Key) -> b
    kotlinx.coroutines.DisposableHandle invokeOnCompletion$default(kotlinx.coroutines.Job,boolean,boolean,kotlin.jvm.functions.Function1,int,java.lang.Object) -> c
    kotlin.coroutines.CoroutineContext minusKey(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext$Key) -> d
kotlinx.coroutines.Job$Key -> f1.v0$b:
    kotlinx.coroutines.Job$Key $$INSTANCE -> d
kotlinx.coroutines.JobCancellationException -> f1.w0:
    kotlinx.coroutines.Job job -> d
kotlinx.coroutines.JobCancellingNode -> f1.x0:
kotlinx.coroutines.JobKt -> f1.y0:
    void cancel(kotlin.coroutines.CoroutineContext,java.util.concurrent.CancellationException) -> a
kotlinx.coroutines.JobKt__JobKt -> f1.z0:
    void cancel(kotlin.coroutines.CoroutineContext,java.util.concurrent.CancellationException) -> a
kotlinx.coroutines.JobNode -> f1.a1:
    kotlinx.coroutines.JobSupport job -> g
    boolean isActive() -> a
    void dispose() -> b
    kotlinx.coroutines.NodeList getList() -> d
    kotlinx.coroutines.JobSupport getJob() -> t
    void setJob(kotlinx.coroutines.JobSupport) -> u
kotlinx.coroutines.JobSupport -> f1.b1:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _state$FU -> d
    java.lang.Throwable createCauseException(java.lang.Object) -> A
    java.lang.Object finalizeFinishingState(kotlinx.coroutines.JobSupport$Finishing,java.lang.Object) -> B
    kotlinx.coroutines.ChildHandleNode firstChild(kotlinx.coroutines.Incomplete) -> C
    java.lang.Throwable getExceptionOrNull(java.lang.Object) -> D
    java.lang.Throwable getFinalRootCause(kotlinx.coroutines.JobSupport$Finishing,java.util.List) -> E
    boolean getHandlesException$kotlinx_coroutines_core() -> F
    boolean getOnCancelComplete$kotlinx_coroutines_core() -> G
    kotlinx.coroutines.NodeList getOrPromoteCancellingList(kotlinx.coroutines.Incomplete) -> H
    kotlinx.coroutines.ChildHandle getParentHandle$kotlinx_coroutines_core() -> I
    java.lang.Object getState$kotlinx_coroutines_core() -> J
    boolean handleJobException(java.lang.Throwable) -> K
    void handleOnCompletionException$kotlinx_coroutines_core(java.lang.Throwable) -> L
    boolean isScopedCoroutine() -> M
    java.lang.Object makeCancelling(java.lang.Object) -> N
    java.lang.Object makeCompletingOnce$kotlinx_coroutines_core(java.lang.Object) -> O
    kotlinx.coroutines.JobNode makeNode(kotlin.jvm.functions.Function1,boolean) -> P
    java.lang.String nameString$kotlinx_coroutines_core() -> Q
    kotlinx.coroutines.ChildHandleNode nextChild(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> R
    void notifyCancelling(kotlinx.coroutines.NodeList,java.lang.Throwable) -> S
    void notifyCompletion(kotlinx.coroutines.NodeList,java.lang.Throwable) -> T
    void onCancelling(java.lang.Throwable) -> U
    void onCompletionInternal(java.lang.Object) -> V
    void promoteEmptyToNodeList(kotlinx.coroutines.Empty) -> W
    void promoteSingleToNodeList(kotlinx.coroutines.JobNode) -> X
    void removeNode$kotlinx_coroutines_core(kotlinx.coroutines.JobNode) -> Y
    void setParentHandle$kotlinx_coroutines_core(kotlinx.coroutines.ChildHandle) -> Z
    boolean isActive() -> a
    java.lang.String stateString(java.lang.Object) -> a0
    kotlinx.coroutines.DisposableHandle invokeOnCompletion(boolean,boolean,kotlin.jvm.functions.Function1) -> b
    java.util.concurrent.CancellationException toCancellationException(java.lang.Throwable,java.lang.String) -> b0
    java.util.concurrent.CancellationException toCancellationException$default(kotlinx.coroutines.JobSupport,java.lang.Throwable,java.lang.String,int,java.lang.Object) -> c0
    java.util.concurrent.CancellationException getChildJobCancellationCause() -> d
    java.lang.String toDebugString() -> d0
    boolean tryFinalizeSimpleState(kotlinx.coroutines.Incomplete,java.lang.Object) -> e0
    void parentCancelled(kotlinx.coroutines.ParentJob) -> f
    boolean tryMakeCancelling(kotlinx.coroutines.Incomplete,java.lang.Throwable) -> f0
    java.util.concurrent.CancellationException getCancellationException() -> g
    java.lang.Object tryMakeCompleting(java.lang.Object,java.lang.Object) -> g0
    java.lang.Object tryMakeCompletingSlowPath(kotlinx.coroutines.Incomplete,java.lang.Object) -> h0
    boolean tryWaitForChild(kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> i0
    void cancel(java.util.concurrent.CancellationException) -> m
    java.lang.String access$cancellationExceptionMessage(kotlinx.coroutines.JobSupport) -> n
    void access$continueCompleting(kotlinx.coroutines.JobSupport,kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> o
    boolean addLastAtomic(java.lang.Object,kotlinx.coroutines.NodeList,kotlinx.coroutines.JobNode) -> p
    void addSuppressedExceptions(java.lang.Throwable,java.util.List) -> q
    void afterCompletion(java.lang.Object) -> r
    boolean cancelImpl$kotlinx_coroutines_core(java.lang.Object) -> s
    void cancelInternal(java.lang.Throwable) -> t
    java.lang.Object cancelMakeCompleting(java.lang.Object) -> u
    boolean cancelParent(java.lang.Throwable) -> v
    java.lang.String cancellationExceptionMessage() -> w
    boolean childCancelled(java.lang.Throwable) -> x
    void completeStateFinalization(kotlinx.coroutines.Incomplete,java.lang.Object) -> y
    void continueCompleting(kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> z
kotlinx.coroutines.JobSupport$ChildCompletion -> f1.b1$a:
    java.lang.Object proposedUpdate -> k
    kotlinx.coroutines.JobSupport$Finishing state -> i
    kotlinx.coroutines.ChildHandleNode child -> j
    kotlinx.coroutines.JobSupport parent -> h
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.JobSupport$Finishing -> f1.b1$b:
    kotlinx.coroutines.NodeList list -> d
    boolean isActive() -> a
    void addExceptionLocked(java.lang.Throwable) -> b
    java.util.ArrayList allocateList() -> c
    kotlinx.coroutines.NodeList getList() -> d
    java.lang.Object getExceptionsHolder() -> e
    java.lang.Throwable getRootCause() -> f
    boolean isCancelling() -> g
    boolean isCompleting() -> h
    boolean isSealed() -> i
    java.util.List sealLocked(java.lang.Throwable) -> j
    void setCompleting(boolean) -> k
    void setExceptionsHolder(java.lang.Object) -> l
    void setRootCause(java.lang.Throwable) -> m
kotlinx.coroutines.JobSupport$addLastAtomic$$inlined$addLastIf$1 -> f1.b1$c:
    kotlinx.coroutines.JobSupport this$0 -> e
    java.lang.Object $expect$inlined -> f
    kotlinx.coroutines.internal.LockFreeLinkedListNode $node -> d
    java.lang.Object prepare(java.lang.Object) -> g
    java.lang.Object prepare(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
kotlinx.coroutines.JobSupportKt -> f1.c1:
    kotlinx.coroutines.internal.Symbol COMPLETING_ALREADY -> a
    kotlinx.coroutines.internal.Symbol TOO_LATE_TO_CANCEL -> d
    kotlinx.coroutines.internal.Symbol SEALED -> e
    kotlinx.coroutines.internal.Symbol COMPLETING_WAITING_CHILDREN -> b
    kotlinx.coroutines.internal.Symbol COMPLETING_RETRY -> c
    kotlinx.coroutines.Empty EMPTY_NEW -> f
    kotlinx.coroutines.Empty EMPTY_ACTIVE -> g
    kotlinx.coroutines.internal.Symbol access$getCOMPLETING_ALREADY$p() -> a
    kotlinx.coroutines.internal.Symbol access$getCOMPLETING_RETRY$p() -> b
    kotlinx.coroutines.Empty access$getEMPTY_ACTIVE$p() -> c
    kotlinx.coroutines.internal.Symbol access$getSEALED$p() -> d
    kotlinx.coroutines.internal.Symbol access$getTOO_LATE_TO_CANCEL$p() -> e
    java.lang.Object boxIncomplete(java.lang.Object) -> f
kotlinx.coroutines.MainCoroutineDispatcher -> f1.d1:
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> n
    java.lang.String toStringInternalImpl() -> o
kotlinx.coroutines.NodeList -> f1.e1:
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> d
kotlinx.coroutines.NonDisposableHandle -> f1.f1:
    kotlinx.coroutines.NonDisposableHandle INSTANCE -> d
    void dispose() -> b
    boolean childCancelled(java.lang.Throwable) -> c
kotlinx.coroutines.NotCompleted -> f1.g1:
kotlinx.coroutines.ParentJob -> f1.h1:
    java.util.concurrent.CancellationException getChildJobCancellationCause() -> d
kotlinx.coroutines.ThreadContextElement -> f1.i1:
    void restoreThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> e
    java.lang.Object updateThreadContext(kotlin.coroutines.CoroutineContext) -> k
kotlinx.coroutines.ThreadLocalEventLoop -> f1.j1:
    kotlinx.coroutines.ThreadLocalEventLoop INSTANCE -> a
    java.lang.ThreadLocal ref -> b
    kotlinx.coroutines.EventLoop getEventLoop$kotlinx_coroutines_core() -> a
    void resetEventLoop$kotlinx_coroutines_core() -> b
    void setEventLoop$kotlinx_coroutines_core(kotlinx.coroutines.EventLoop) -> c
kotlinx.coroutines.Unconfined -> f1.k1:
    kotlinx.coroutines.Unconfined INSTANCE -> e
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> h
kotlinx.coroutines.UndispatchedCoroutine -> f1.l1:
    java.lang.ThreadLocal threadStateToRecover -> g
    void afterResume(java.lang.Object) -> j0
    boolean clearThreadContext() -> m0
    void saveThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> n0
kotlinx.coroutines.UndispatchedMarker -> f1.m1:
    kotlinx.coroutines.UndispatchedMarker INSTANCE -> d
kotlinx.coroutines.YieldContext -> f1.n1:
    kotlinx.coroutines.YieldContext$Key Key -> e
    boolean dispatcherWasUnconfined -> d
kotlinx.coroutines.YieldContext$Key -> f1.n1$a:
kotlinx.coroutines.android.HandlerContext -> g1.a:
    java.lang.String name -> f
    android.os.Handler handler -> e
    boolean invokeImmediately -> g
    kotlinx.coroutines.android.HandlerContext immediate -> h
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> h
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> n
    void cancelOnRejection(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> p
    kotlinx.coroutines.android.HandlerContext getImmediate() -> q
kotlinx.coroutines.android.HandlerDispatcher -> g1.b:
kotlinx.coroutines.android.HandlerDispatcherKt -> g1.c:
    kotlinx.coroutines.android.HandlerDispatcher Main -> a
    android.os.Handler asHandler(android.os.Looper,boolean) -> a
kotlinx.coroutines.internal.ArrayQueue -> kotlinx.coroutines.internal.a:
    java.lang.Object[] elements -> a
    int head -> b
    int tail -> c
    void addLast(java.lang.Object) -> a
    void ensureCapacity() -> b
    boolean isEmpty() -> c
    java.lang.Object removeFirstOrNull() -> d
kotlinx.coroutines.internal.AtomicKt -> kotlinx.coroutines.internal.b:
    java.lang.Object RETRY_ATOMIC -> b
    java.lang.Object NO_DECISION -> a
kotlinx.coroutines.internal.AtomicOp -> kotlinx.coroutines.internal.c:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _consensus$FU -> a
    kotlinx.coroutines.internal.AtomicOp getAtomicOp() -> a
    java.lang.Object perform(java.lang.Object) -> c
    void complete(java.lang.Object,java.lang.Object) -> d
    java.lang.Object decide(java.lang.Object) -> e
    long getOpSequence() -> f
    java.lang.Object prepare(java.lang.Object) -> g
kotlinx.coroutines.internal.DispatchedContinuation -> kotlinx.coroutines.internal.d:
    java.lang.Object countOrElement -> j
    java.lang.Object _state -> i
    kotlinx.coroutines.CoroutineDispatcher dispatcher -> g
    kotlin.coroutines.Continuation continuation -> h
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _reusableCancellableContinuation$FU -> k
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    kotlin.coroutines.CoroutineContext getContext() -> c
    java.lang.Object takeState$kotlinx_coroutines_core() -> g
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> h
    void awaitReusability() -> i
    kotlinx.coroutines.CancellableContinuationImpl getReusableCancellableContinuation() -> j
    boolean isReusable() -> k
    void resumeWith(java.lang.Object) -> l
    void release() -> m
kotlinx.coroutines.internal.DispatchedContinuationKt -> kotlinx.coroutines.internal.e:
    kotlinx.coroutines.internal.Symbol UNDEFINED -> a
    kotlinx.coroutines.internal.Symbol REUSABLE_CLAIMED -> b
    kotlinx.coroutines.internal.Symbol access$getUNDEFINED$p() -> a
    void resumeCancellableWith(kotlin.coroutines.Continuation,java.lang.Object,kotlin.jvm.functions.Function1) -> b
    void resumeCancellableWith$default(kotlin.coroutines.Continuation,java.lang.Object,kotlin.jvm.functions.Function1,int,java.lang.Object) -> c
kotlinx.coroutines.internal.FastServiceLoader -> kotlinx.coroutines.internal.f:
    kotlinx.coroutines.internal.FastServiceLoader INSTANCE -> a
    java.lang.Object getProviderInstance(java.lang.String,java.lang.ClassLoader,java.lang.Class) -> a
    java.util.List load(java.lang.Class,java.lang.ClassLoader) -> b
    java.util.List loadMainDispatcherFactory$kotlinx_coroutines_core() -> c
    java.util.List loadProviders$kotlinx_coroutines_core(java.lang.Class,java.lang.ClassLoader) -> d
    java.util.List parse(java.net.URL) -> e
    java.util.List parseFile(java.io.BufferedReader) -> f
kotlinx.coroutines.internal.FastServiceLoaderKt -> kotlinx.coroutines.internal.g:
    boolean ANDROID_DETECTED -> a
    boolean getANDROID_DETECTED() -> a
kotlinx.coroutines.internal.LimitedDispatcher -> kotlinx.coroutines.internal.h:
    java.lang.Object workerAllocationLock -> i
    kotlinx.coroutines.CoroutineDispatcher dispatcher -> e
    kotlinx.coroutines.internal.LockFreeTaskQueue queue -> h
    int parallelism -> f
    kotlinx.coroutines.Delay $$delegate_0 -> g
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean addAndTryDispatching(java.lang.Runnable) -> n
    boolean tryAllocateWorker() -> o
kotlinx.coroutines.internal.LimitedDispatcherKt -> kotlinx.coroutines.internal.i:
    void checkParallelism(int) -> a
kotlinx.coroutines.internal.LockFreeLinkedListHead -> kotlinx.coroutines.internal.j:
    boolean isRemoved() -> n
kotlinx.coroutines.internal.LockFreeLinkedListKt -> kotlinx.coroutines.internal.k:
    java.lang.Object LIST_EMPTY -> b
    java.lang.Object CONDITION_FALSE -> a
    java.lang.Object getCONDITION_FALSE() -> a
    kotlinx.coroutines.internal.LockFreeLinkedListNode unwrap(java.lang.Object) -> b
kotlinx.coroutines.internal.LockFreeLinkedListNode -> kotlinx.coroutines.internal.l:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _removedRef$FU -> f
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _next$FU -> d
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _prev$FU -> e
    void access$finishAdd(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode) -> f
    boolean addOneIfEmpty(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> g
    kotlinx.coroutines.internal.LockFreeLinkedListNode correctPrev(kotlinx.coroutines.internal.OpDescriptor) -> h
    kotlinx.coroutines.internal.LockFreeLinkedListNode findPrevNonRemoved(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
    void finishAdd(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> j
    java.lang.Object getNext() -> k
    kotlinx.coroutines.internal.LockFreeLinkedListNode getNextNode() -> l
    kotlinx.coroutines.internal.LockFreeLinkedListNode getPrevNode() -> m
    boolean isRemoved() -> n
    boolean remove() -> o
    kotlinx.coroutines.internal.LockFreeLinkedListNode removeOrNext() -> p
    kotlinx.coroutines.internal.Removed removed() -> q
    int tryCondAddNext(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp) -> r
kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp -> kotlinx.coroutines.internal.l$a:
    kotlinx.coroutines.internal.LockFreeLinkedListNode oldNext -> c
    kotlinx.coroutines.internal.LockFreeLinkedListNode newNode -> b
    void complete(java.lang.Object,java.lang.Object) -> d
    void complete(kotlinx.coroutines.internal.LockFreeLinkedListNode,java.lang.Object) -> h
kotlinx.coroutines.internal.LockFreeLinkedListNode$toString$1 -> kotlinx.coroutines.internal.l$b:
kotlinx.coroutines.internal.LockFreeTaskQueue -> kotlinx.coroutines.internal.m:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _cur$FU -> a
    boolean addLast(java.lang.Object) -> a
    void close() -> b
    int getSize() -> c
    java.lang.Object removeFirstOrNull() -> d
kotlinx.coroutines.internal.LockFreeTaskQueueCore -> kotlinx.coroutines.internal.n:
    java.util.concurrent.atomic.AtomicLongFieldUpdater _state$FU -> g
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _next$FU -> f
    kotlinx.coroutines.internal.Symbol REMOVE_FROZEN -> h
    kotlinx.coroutines.internal.LockFreeTaskQueueCore$Companion Companion -> e
    java.util.concurrent.atomic.AtomicReferenceArray array -> d
    boolean singleConsumer -> b
    int mask -> c
    int capacity -> a
    int addLast(java.lang.Object) -> a
    kotlinx.coroutines.internal.LockFreeTaskQueueCore allocateNextCopy(long) -> b
    kotlinx.coroutines.internal.LockFreeTaskQueueCore allocateOrGetNextCopy(long) -> c
    boolean close() -> d
    kotlinx.coroutines.internal.LockFreeTaskQueueCore fillPlaceholder(int,java.lang.Object) -> e
    int getSize() -> f
    boolean isEmpty() -> g
    long markFrozen() -> h
    kotlinx.coroutines.internal.LockFreeTaskQueueCore next() -> i
    java.lang.Object removeFirstOrNull() -> j
    kotlinx.coroutines.internal.LockFreeTaskQueueCore removeSlowPath(int,int) -> k
kotlinx.coroutines.internal.LockFreeTaskQueueCore$Companion -> kotlinx.coroutines.internal.n$a:
    int addFailReason(long) -> a
    long updateHead(long,int) -> b
    long updateTail(long,int) -> c
    long wo(long,long) -> d
kotlinx.coroutines.internal.LockFreeTaskQueueCore$Placeholder -> kotlinx.coroutines.internal.n$b:
    int index -> a
kotlinx.coroutines.internal.MainDispatcherFactory -> kotlinx.coroutines.internal.o:
kotlinx.coroutines.internal.MainDispatcherLoader -> kotlinx.coroutines.internal.p:
    kotlinx.coroutines.internal.MainDispatcherLoader INSTANCE -> a
    kotlinx.coroutines.MainCoroutineDispatcher dispatcher -> c
    boolean FAST_SERVICE_LOADER_ENABLED -> b
    kotlinx.coroutines.MainCoroutineDispatcher loadMainDispatcher() -> a
kotlinx.coroutines.internal.MainDispatchersKt -> kotlinx.coroutines.internal.q:
    boolean SUPPORT_MISSING -> a
    kotlinx.coroutines.internal.MissingMainCoroutineDispatcher createMissingDispatcher(java.lang.Throwable,java.lang.String) -> a
    kotlinx.coroutines.internal.MissingMainCoroutineDispatcher createMissingDispatcher$default(java.lang.Throwable,java.lang.String,int,java.lang.Object) -> b
    boolean isMissing(kotlinx.coroutines.MainCoroutineDispatcher) -> c
    java.lang.Void throwMissingMainDispatcherException() -> d
    kotlinx.coroutines.MainCoroutineDispatcher tryCreateDispatcher(kotlinx.coroutines.internal.MainDispatcherFactory,java.util.List) -> e
kotlinx.coroutines.internal.MissingMainCoroutineDispatcher -> kotlinx.coroutines.internal.r:
    java.lang.String errorHint -> f
    java.lang.Throwable cause -> e
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> h
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> n
    java.lang.Void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> p
    java.lang.Void missing() -> q
kotlinx.coroutines.internal.OpDescriptor -> kotlinx.coroutines.internal.s:
    kotlinx.coroutines.internal.AtomicOp getAtomicOp() -> a
    boolean isEarlierThan(kotlinx.coroutines.internal.OpDescriptor) -> b
    java.lang.Object perform(java.lang.Object) -> c
kotlinx.coroutines.internal.Removed -> kotlinx.coroutines.internal.t:
    kotlinx.coroutines.internal.LockFreeLinkedListNode ref -> a
kotlinx.coroutines.internal.ResizableAtomicArray -> kotlinx.coroutines.internal.u:
    int currentLength() -> a
    java.lang.Object get(int) -> b
    void setSynchronized(int,java.lang.Object) -> c
kotlinx.coroutines.internal.ScopeCoroutine -> kotlinx.coroutines.internal.v:
    kotlin.coroutines.Continuation uCont -> f
    boolean isScopedCoroutine() -> M
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> h
    void afterResume(java.lang.Object) -> j0
    void afterCompletion(java.lang.Object) -> r
kotlinx.coroutines.internal.Symbol -> kotlinx.coroutines.internal.w:
    java.lang.String symbol -> a
kotlinx.coroutines.internal.SystemPropsKt -> kotlinx.coroutines.internal.x:
    int getAVAILABLE_PROCESSORS() -> a
    int systemProp(java.lang.String,int,int,int) -> b
    long systemProp(java.lang.String,long,long,long) -> c
    java.lang.String systemProp(java.lang.String) -> d
    boolean systemProp(java.lang.String,boolean) -> e
    int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object) -> f
    long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object) -> g
kotlinx.coroutines.internal.SystemPropsKt__SystemPropsKt -> kotlinx.coroutines.internal.y:
    int AVAILABLE_PROCESSORS -> a
    int getAVAILABLE_PROCESSORS() -> a
    java.lang.String systemProp(java.lang.String) -> b
kotlinx.coroutines.internal.SystemPropsKt__SystemProps_commonKt -> kotlinx.coroutines.internal.z:
    int systemProp(java.lang.String,int,int,int) -> a
    long systemProp(java.lang.String,long,long,long) -> b
    boolean systemProp(java.lang.String,boolean) -> c
    int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object) -> d
    long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object) -> e
kotlinx.coroutines.internal.ThreadContextKt -> kotlinx.coroutines.internal.a0:
    kotlinx.coroutines.internal.Symbol NO_THREAD_ELEMENTS -> a
    kotlin.jvm.functions.Function2 findOne -> c
    kotlin.jvm.functions.Function2 countAll -> b
    kotlin.jvm.functions.Function2 updateState -> d
    void restoreThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> a
    java.lang.Object threadContextElements(kotlin.coroutines.CoroutineContext) -> b
    java.lang.Object updateThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> c
kotlinx.coroutines.internal.ThreadContextKt$countAll$1 -> kotlinx.coroutines.internal.a0$a:
    kotlinx.coroutines.internal.ThreadContextKt$countAll$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    java.lang.Object invoke(java.lang.Object,kotlin.coroutines.CoroutineContext$Element) -> b
kotlinx.coroutines.internal.ThreadContextKt$findOne$1 -> kotlinx.coroutines.internal.a0$b:
    kotlinx.coroutines.internal.ThreadContextKt$findOne$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    kotlinx.coroutines.ThreadContextElement invoke(kotlinx.coroutines.ThreadContextElement,kotlin.coroutines.CoroutineContext$Element) -> b
kotlinx.coroutines.internal.ThreadContextKt$updateState$1 -> kotlinx.coroutines.internal.a0$c:
    kotlinx.coroutines.internal.ThreadContextKt$updateState$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    kotlinx.coroutines.internal.ThreadState invoke(kotlinx.coroutines.internal.ThreadState,kotlin.coroutines.CoroutineContext$Element) -> b
kotlinx.coroutines.internal.ThreadSafeHeap -> kotlinx.coroutines.internal.b0:
    void addImpl(kotlinx.coroutines.internal.ThreadSafeHeapNode) -> a
    kotlinx.coroutines.internal.ThreadSafeHeapNode firstImpl() -> b
    int getSize() -> c
    boolean isEmpty() -> d
    kotlinx.coroutines.internal.ThreadSafeHeapNode peek() -> e
    kotlinx.coroutines.internal.ThreadSafeHeapNode[] realloc() -> f
    boolean remove(kotlinx.coroutines.internal.ThreadSafeHeapNode) -> g
    kotlinx.coroutines.internal.ThreadSafeHeapNode removeAtImpl(int) -> h
    kotlinx.coroutines.internal.ThreadSafeHeapNode removeFirstOrNull() -> i
    void setSize(int) -> j
    void siftDownFrom(int) -> k
    void siftUpFrom(int) -> l
    void swap(int,int) -> m
kotlinx.coroutines.internal.ThreadSafeHeapNode -> kotlinx.coroutines.internal.c0:
    void setHeap(kotlinx.coroutines.internal.ThreadSafeHeap) -> a
    kotlinx.coroutines.internal.ThreadSafeHeap getHeap() -> d
kotlinx.coroutines.internal.ThreadState -> kotlinx.coroutines.internal.d0:
    java.lang.Object[] values -> b
    kotlinx.coroutines.ThreadContextElement[] elements -> c
    int i -> d
    kotlin.coroutines.CoroutineContext context -> a
    void append(kotlinx.coroutines.ThreadContextElement,java.lang.Object) -> a
    void restore(kotlin.coroutines.CoroutineContext) -> b
kotlinx.coroutines.scheduling.CoroutineScheduler -> kotlinx.coroutines.scheduling.a:
    java.lang.String schedulerName -> g
    kotlinx.coroutines.scheduling.GlobalQueue globalBlockingQueue -> i
    kotlinx.coroutines.internal.Symbol NOT_IN_STACK -> o
    long idleWorkerKeepAliveNs -> f
    int corePoolSize -> d
    kotlinx.coroutines.internal.ResizableAtomicArray workers -> j
    int maxPoolSize -> e
    kotlinx.coroutines.scheduling.GlobalQueue globalCpuQueue -> h
    java.util.concurrent.atomic.AtomicLongFieldUpdater controlState$FU -> m
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _isTerminated$FU -> n
    kotlinx.coroutines.scheduling.CoroutineScheduler$Companion Companion -> k
    java.util.concurrent.atomic.AtomicLongFieldUpdater parkedWorkersStack$FU -> l
    boolean addToGlobalQueue(kotlinx.coroutines.scheduling.Task) -> a
    int createNewWorker() -> b
    kotlinx.coroutines.scheduling.Task createTask(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext) -> c
    kotlinx.coroutines.scheduling.CoroutineScheduler$Worker currentWorker() -> d
    void dispatch(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean) -> e
    void dispatch$default(kotlinx.coroutines.scheduling.CoroutineScheduler,java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean,int,java.lang.Object) -> f
    int parkedWorkersStackNextIndex(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> g
    kotlinx.coroutines.scheduling.CoroutineScheduler$Worker parkedWorkersStackPop() -> h
    boolean parkedWorkersStackPush(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> i
    void parkedWorkersStackTopUpdate(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker,int,int) -> j
    void runSafely(kotlinx.coroutines.scheduling.Task) -> k
    void shutdown(long) -> l
    void signalBlockingWork(boolean) -> m
    void signalCpuWork() -> n
    kotlinx.coroutines.scheduling.Task submitToLocalQueue(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker,kotlinx.coroutines.scheduling.Task,boolean) -> o
    boolean tryCreateWorker(long) -> p
    boolean tryCreateWorker$default(kotlinx.coroutines.scheduling.CoroutineScheduler,long,int,java.lang.Object) -> q
    boolean tryUnpark() -> r
kotlinx.coroutines.scheduling.CoroutineScheduler$Companion -> kotlinx.coroutines.scheduling.a$a:
kotlinx.coroutines.scheduling.CoroutineScheduler$WhenMappings -> kotlinx.coroutines.scheduling.a$b:
    int[] $EnumSwitchMapping$0 -> a
kotlinx.coroutines.scheduling.CoroutineScheduler$Worker -> kotlinx.coroutines.scheduling.a$c:
    kotlinx.coroutines.scheduling.WorkQueue localQueue -> d
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState state -> e
    long terminationDeadline -> f
    boolean mayHaveLocalTasks -> i
    int rngState -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler this$0 -> j
    long minDelayUntilStealableTaskNs -> g
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater workerCtl$FU -> k
    kotlinx.coroutines.scheduling.CoroutineScheduler access$getThis$0$p(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> a
    void afterTask(int) -> b
    void beforeTask(int) -> c
    void executeTask(kotlinx.coroutines.scheduling.Task) -> d
    kotlinx.coroutines.scheduling.Task findAnyTask(boolean) -> e
    kotlinx.coroutines.scheduling.Task findTask(boolean) -> f
    int getIndexInArray() -> g
    java.lang.Object getNextParkedWorker() -> h
    void idleReset(int) -> i
    boolean inStack() -> j
    int nextInt(int) -> k
    void park() -> l
    kotlinx.coroutines.scheduling.Task pollGlobalQueues() -> m
    void runWorker() -> n
    void setIndexInArray(int) -> o
    void setNextParkedWorker(java.lang.Object) -> p
    boolean tryAcquireCpuPermit() -> q
    void tryPark() -> r
    boolean tryReleaseCpu(kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState) -> s
    kotlinx.coroutines.scheduling.Task trySteal(boolean) -> t
    void tryTerminateWorker() -> u
kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState -> kotlinx.coroutines.scheduling.a$d:
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState CPU_ACQUIRED -> d
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState BLOCKING -> e
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState PARKING -> f
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState DORMANT -> g
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState TERMINATED -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState[] $VALUES -> i
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState[] $values() -> a
kotlinx.coroutines.scheduling.DefaultIoScheduler -> kotlinx.coroutines.scheduling.b:
    kotlinx.coroutines.CoroutineDispatcher default -> g
    kotlinx.coroutines.scheduling.DefaultIoScheduler INSTANCE -> f
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
kotlinx.coroutines.scheduling.DefaultScheduler -> kotlinx.coroutines.scheduling.c:
    kotlinx.coroutines.scheduling.DefaultScheduler INSTANCE -> k
kotlinx.coroutines.scheduling.GlobalQueue -> kotlinx.coroutines.scheduling.d:
kotlinx.coroutines.scheduling.NanoTimeSource -> kotlinx.coroutines.scheduling.e:
    kotlinx.coroutines.scheduling.NanoTimeSource INSTANCE -> a
    long nanoTime() -> a
kotlinx.coroutines.scheduling.SchedulerCoroutineDispatcher -> kotlinx.coroutines.scheduling.f:
    java.lang.String schedulerName -> i
    long idleWorkerKeepAliveNs -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler coroutineScheduler -> j
    int corePoolSize -> f
    int maxPoolSize -> g
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    kotlinx.coroutines.scheduling.CoroutineScheduler createScheduler() -> n
    void dispatchWithContext$kotlinx_coroutines_core(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean) -> o
kotlinx.coroutines.scheduling.SchedulerTimeSource -> kotlinx.coroutines.scheduling.g:
    long nanoTime() -> a
kotlinx.coroutines.scheduling.Task -> kotlinx.coroutines.scheduling.h:
    kotlinx.coroutines.scheduling.TaskContext taskContext -> e
    long submissionTime -> d
kotlinx.coroutines.scheduling.TaskContext -> kotlinx.coroutines.scheduling.i:
    int getTaskMode() -> a
    void afterTask() -> b
kotlinx.coroutines.scheduling.TaskContextImpl -> kotlinx.coroutines.scheduling.j:
    int taskMode -> a
    int getTaskMode() -> a
    void afterTask() -> b
kotlinx.coroutines.scheduling.TaskImpl -> kotlinx.coroutines.scheduling.k:
    java.lang.Runnable block -> f
kotlinx.coroutines.scheduling.TasksKt -> kotlinx.coroutines.scheduling.l:
    kotlinx.coroutines.scheduling.TaskContext BlockingContext -> g
    kotlinx.coroutines.scheduling.SchedulerTimeSource schedulerTimeSource -> e
    kotlinx.coroutines.scheduling.TaskContext NonBlockingContext -> f
    long WORK_STEALING_TIME_RESOLUTION_NS -> a
    long IDLE_WORKER_KEEP_ALIVE_NS -> d
    int CORE_POOL_SIZE -> b
    int MAX_POOL_SIZE -> c
kotlinx.coroutines.scheduling.UnlimitedIoScheduler -> kotlinx.coroutines.scheduling.m:
    kotlinx.coroutines.scheduling.UnlimitedIoScheduler INSTANCE -> e
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
kotlinx.coroutines.scheduling.WorkQueue -> kotlinx.coroutines.scheduling.o:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater lastScheduledTask$FU -> b
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater blockingTasksInBuffer$FU -> e
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater consumerIndex$FU -> d
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater producerIndex$FU -> c
    java.util.concurrent.atomic.AtomicReferenceArray buffer -> a
    kotlinx.coroutines.scheduling.Task add(kotlinx.coroutines.scheduling.Task,boolean) -> a
    kotlinx.coroutines.scheduling.Task add$default(kotlinx.coroutines.scheduling.WorkQueue,kotlinx.coroutines.scheduling.Task,boolean,int,java.lang.Object) -> b
    kotlinx.coroutines.scheduling.Task addLast(kotlinx.coroutines.scheduling.Task) -> c
    void decrementIfBlocking(kotlinx.coroutines.scheduling.Task) -> d
    int getBufferSize$kotlinx_coroutines_core() -> e
    int getSize$kotlinx_coroutines_core() -> f
    void offloadAllWorkTo(kotlinx.coroutines.scheduling.GlobalQueue) -> g
    kotlinx.coroutines.scheduling.Task poll() -> h
    kotlinx.coroutines.scheduling.Task pollBuffer() -> i
    boolean pollTo(kotlinx.coroutines.scheduling.GlobalQueue) -> j
    long tryStealBlockingFrom(kotlinx.coroutines.scheduling.WorkQueue) -> k
    long tryStealFrom(kotlinx.coroutines.scheduling.WorkQueue) -> l
    long tryStealLastScheduled(kotlinx.coroutines.scheduling.WorkQueue,boolean) -> m
kotlinx.coroutines.scheduling.WorkQueue$$ExternalSyntheticBackportWithForwarding0 -> kotlinx.coroutines.scheduling.n:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean kotlinx.coroutines.scheduling.WorkQueue$$InternalSyntheticBackportWithForwarding$1$fea41a45c8396694b734bf6713722fe4232fc4db1f67f3f538fe971a17baaead$0.m(java.util.concurrent.atomic.AtomicReferenceArray,int,java.lang.Object,java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
